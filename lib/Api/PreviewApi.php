<?php
/**
 * PreviewApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * PreviewApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PreviewApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation destiny2GetClanAggregateStats
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20051
     */
    public function destiny2GetClanAggregateStats($group_id, $modes = null)
    {
        list($response) = $this->destiny2GetClanAggregateStatsWithHttpInfo($group_id, $modes);
        return $response;
    }

    /**
     * Operation destiny2GetClanAggregateStatsWithHttpInfo
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20051, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanAggregateStatsWithHttpInfo($group_id, $modes = null)
    {
        $request = $this->destiny2GetClanAggregateStatsRequest($group_id, $modes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20051' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20051', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20051';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20051',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanAggregateStatsAsync
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanAggregateStatsAsync($group_id, $modes = null)
    {
        return $this->destiny2GetClanAggregateStatsAsyncWithHttpInfo($group_id, $modes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanAggregateStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanAggregateStatsAsyncWithHttpInfo($group_id, $modes = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20051';
        $request = $this->destiny2GetClanAggregateStatsRequest($group_id, $modes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanAggregateStats'
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetClanAggregateStatsRequest($group_id, $modes = null)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling destiny2GetClanAggregateStats'
            );
        }

        $resourcePath = '/Destiny2/Stats/AggregateClanStats/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanLeaderboards
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function destiny2GetClanLeaderboards($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetClanLeaderboardsWithHttpInfo($group_id, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetClanLeaderboardsWithHttpInfo
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanLeaderboardsWithHttpInfo($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetClanLeaderboardsRequest($group_id, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanLeaderboardsAsync
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanLeaderboardsAsync($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetClanLeaderboardsAsyncWithHttpInfo($group_id, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanLeaderboardsAsyncWithHttpInfo($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->destiny2GetClanLeaderboardsRequest($group_id, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanLeaderboards'
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetClanLeaderboardsRequest($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling destiny2GetClanLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/Clans/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($maxtop)) {
            $maxtop = ObjectSerializer::serializeCollection($maxtop, '', true);
        }
        if ($maxtop !== null) {
            $queryParams['maxtop'] = $maxtop;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($statid)) {
            $statid = ObjectSerializer::serializeCollection($statid, '', true);
        }
        if ($statid !== null) {
            $queryParams['statid'] = $statid;
        }


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLeaderboards
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function destiny2GetLeaderboards($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetLeaderboardsWithHttpInfo($destiny_membership_id, $membership_type, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetLeaderboardsWithHttpInfo
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLeaderboardsWithHttpInfo($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetLeaderboardsRequest($destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLeaderboardsAsync
     *
     * 
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsAsync($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetLeaderboardsAsyncWithHttpInfo($destiny_membership_id, $membership_type, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsAsyncWithHttpInfo($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->destiny2GetLeaderboardsRequest($destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLeaderboards'
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetLeaderboardsRequest($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetLeaderboards'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($maxtop)) {
            $maxtop = ObjectSerializer::serializeCollection($maxtop, '', true);
        }
        if ($maxtop !== null) {
            $queryParams['maxtop'] = $maxtop;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($statid)) {
            $statid = ObjectSerializer::serializeCollection($statid, '', true);
        }
        if ($statid !== null) {
            $queryParams['statid'] = $statid;
        }


        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacter
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function destiny2GetLeaderboardsForCharacter($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetLeaderboardsForCharacterWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterWithHttpInfo
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLeaderboardsForCharacterWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetLeaderboardsForCharacterRequest($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterAsync
     *
     * 
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsForCharacterAsync($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->destiny2GetLeaderboardsForCharacterRequest($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLeaderboardsForCharacter'
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetLeaderboardsForCharacterRequest($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetLeaderboardsForCharacter'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($maxtop)) {
            $maxtop = ObjectSerializer::serializeCollection($maxtop, '', true);
        }
        if ($maxtop !== null) {
            $queryParams['maxtop'] = $maxtop;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($statid)) {
            $statid = ObjectSerializer::serializeCollection($statid, '', true);
        }
        if ($statid !== null) {
            $queryParams['statid'] = $statid;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPublicVendors
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20044
     */
    public function destiny2GetPublicVendors($components = null)
    {
        list($response) = $this->destiny2GetPublicVendorsWithHttpInfo($components);
        return $response;
    }

    /**
     * Operation destiny2GetPublicVendorsWithHttpInfo
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20044, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPublicVendorsWithHttpInfo($components = null)
    {
        $request = $this->destiny2GetPublicVendorsRequest($components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20044' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20044', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20044';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPublicVendorsAsync
     *
     * 
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicVendorsAsync($components = null)
    {
        return $this->destiny2GetPublicVendorsAsyncWithHttpInfo($components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPublicVendorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicVendorsAsyncWithHttpInfo($components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20044';
        $request = $this->destiny2GetPublicVendorsRequest($components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPublicVendors'
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetPublicVendorsRequest($components = null)
    {

        $resourcePath = '/Destiny2/Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2InsertSocketPlug
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20047
     */
    public function destiny2InsertSocketPlug()
    {
        list($response) = $this->destiny2InsertSocketPlugWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2InsertSocketPlugWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20047, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2InsertSocketPlugWithHttpInfo()
    {
        $request = $this->destiny2InsertSocketPlugRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20047' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20047', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20047';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20047',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2InsertSocketPlugAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2InsertSocketPlugAsync()
    {
        return $this->destiny2InsertSocketPlugAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2InsertSocketPlugAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2InsertSocketPlugAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20047';
        $request = $this->destiny2InsertSocketPlugRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2InsertSocketPlug'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2InsertSocketPlugRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/InsertSocketPlug/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
