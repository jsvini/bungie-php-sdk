<?php
/**
 * Destiny2Api
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * Destiny2Api Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class Destiny2Api
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation destiny2AwaGetActionToken
     *
     * @param  string $correlation_id The identifier for the advanced write action request. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20061
     */
    public function destiny2AwaGetActionToken($correlation_id)
    {
        list($response) = $this->destiny2AwaGetActionTokenWithHttpInfo($correlation_id);
        return $response;
    }

    /**
     * Operation destiny2AwaGetActionTokenWithHttpInfo
     *
     * @param  string $correlation_id The identifier for the advanced write action request. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20061, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2AwaGetActionTokenWithHttpInfo($correlation_id)
    {
        $request = $this->destiny2AwaGetActionTokenRequest($correlation_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20061' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20061', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20061';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20061',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2AwaGetActionTokenAsync
     *
     * 
     *
     * @param  string $correlation_id The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaGetActionTokenAsync($correlation_id)
    {
        return $this->destiny2AwaGetActionTokenAsyncWithHttpInfo($correlation_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2AwaGetActionTokenAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $correlation_id The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaGetActionTokenAsyncWithHttpInfo($correlation_id)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20061';
        $request = $this->destiny2AwaGetActionTokenRequest($correlation_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2AwaGetActionToken'
     *
     * @param  string $correlation_id The identifier for the advanced write action request. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2AwaGetActionTokenRequest($correlation_id)
    {
        // verify the required parameter 'correlation_id' is set
        if ($correlation_id === null || (is_array($correlation_id) && count($correlation_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $correlation_id when calling destiny2AwaGetActionToken'
            );
        }

        $resourcePath = '/Destiny2/Awa/GetActionToken/{correlationId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($correlation_id !== null) {
            $resourcePath = str_replace(
                '{' . 'correlationId' . '}',
                ObjectSerializer::toPathValue($correlation_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2AwaInitializeRequest
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20060
     */
    public function destiny2AwaInitializeRequest()
    {
        list($response) = $this->destiny2AwaInitializeRequestWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2AwaInitializeRequestWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20060, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2AwaInitializeRequestWithHttpInfo()
    {
        $request = $this->destiny2AwaInitializeRequestRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20060' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20060', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20060';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20060',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2AwaInitializeRequestAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaInitializeRequestAsync()
    {
        return $this->destiny2AwaInitializeRequestAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2AwaInitializeRequestAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaInitializeRequestAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20060';
        $request = $this->destiny2AwaInitializeRequestRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2AwaInitializeRequest'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2AwaInitializeRequestRequest()
    {

        $resourcePath = '/Destiny2/Awa/Initialize/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResult
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2AwaProvideAuthorizationResult()
    {
        list($response) = $this->destiny2AwaProvideAuthorizationResultWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResultWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2AwaProvideAuthorizationResultWithHttpInfo()
    {
        $request = $this->destiny2AwaProvideAuthorizationResultRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResultAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaProvideAuthorizationResultAsync()
    {
        return $this->destiny2AwaProvideAuthorizationResultAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2AwaProvideAuthorizationResultAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2AwaProvideAuthorizationResultAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2AwaProvideAuthorizationResultRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2AwaProvideAuthorizationResult'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2AwaProvideAuthorizationResultRequest()
    {

        $resourcePath = '/Destiny2/Awa/AwaProvideAuthorizationResult/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2EquipItem
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2EquipItem()
    {
        list($response) = $this->destiny2EquipItemWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2EquipItemWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2EquipItemWithHttpInfo()
    {
        $request = $this->destiny2EquipItemRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2EquipItemAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemAsync()
    {
        return $this->destiny2EquipItemAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2EquipItemAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2EquipItemRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2EquipItem'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2EquipItemRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/EquipItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2EquipItems
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20046
     */
    public function destiny2EquipItems()
    {
        list($response) = $this->destiny2EquipItemsWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2EquipItemsWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20046, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2EquipItemsWithHttpInfo()
    {
        $request = $this->destiny2EquipItemsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20046' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20046', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20046';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20046',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2EquipItemsAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemsAsync()
    {
        return $this->destiny2EquipItemsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2EquipItemsAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2EquipItemsAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20046';
        $request = $this->destiny2EquipItemsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2EquipItems'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2EquipItemsRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/EquipItems/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetActivityHistory
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20055
     */
    public function destiny2GetActivityHistory($character_id, $destiny_membership_id, $membership_type, $count = null, $mode = null, $page = null)
    {
        list($response) = $this->destiny2GetActivityHistoryWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $count, $mode, $page);
        return $response;
    }

    /**
     * Operation destiny2GetActivityHistoryWithHttpInfo
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20055, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetActivityHistoryWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $count = null, $mode = null, $page = null)
    {
        $request = $this->destiny2GetActivityHistoryRequest($character_id, $destiny_membership_id, $membership_type, $count, $mode, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20055' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20055', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20055';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20055',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetActivityHistoryAsync
     *
     * 
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetActivityHistoryAsync($character_id, $destiny_membership_id, $membership_type, $count = null, $mode = null, $page = null)
    {
        return $this->destiny2GetActivityHistoryAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $count, $mode, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetActivityHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetActivityHistoryAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $count = null, $mode = null, $page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20055';
        $request = $this->destiny2GetActivityHistoryRequest($character_id, $destiny_membership_id, $membership_type, $count, $mode, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetActivityHistory'
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $count Number of rows to return (optional)
     * @param  int $mode A filter for the activity mode to be returned. None returns all activities. See the documentation for DestinyActivityModeType for valid values, and pass in string representation. (optional)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetActivityHistoryRequest($character_id, $destiny_membership_id, $membership_type, $count = null, $mode = null, $page = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetActivityHistory'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetActivityHistory'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetActivityHistory'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/Activities/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($count)) {
            $count = ObjectSerializer::serializeCollection($count, '', true);
        }
        if ($count !== null) {
            $queryParams['count'] = $count;
        }
        // query params
        if (is_array($mode)) {
            $mode = ObjectSerializer::serializeCollection($mode, '', true);
        }
        if ($mode !== null) {
            $queryParams['mode'] = $mode;
        }
        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetCharacter
     *
     * @param  int $character_id ID of the character. (required)
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20039
     */
    public function destiny2GetCharacter($character_id, $destiny_membership_id, $membership_type, $components = null)
    {
        list($response) = $this->destiny2GetCharacterWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components);
        return $response;
    }

    /**
     * Operation destiny2GetCharacterWithHttpInfo
     *
     * @param  int $character_id ID of the character. (required)
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetCharacterWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components = null)
    {
        $request = $this->destiny2GetCharacterRequest($character_id, $destiny_membership_id, $membership_type, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20039' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20039', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20039';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetCharacterAsync
     *
     * 
     *
     * @param  int $character_id ID of the character. (required)
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCharacterAsync($character_id, $destiny_membership_id, $membership_type, $components = null)
    {
        return $this->destiny2GetCharacterAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id ID of the character. (required)
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCharacterAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20039';
        $request = $this->destiny2GetCharacterRequest($character_id, $destiny_membership_id, $membership_type, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetCharacter'
     *
     * @param  int $character_id ID of the character. (required)
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetCharacterRequest($character_id, $destiny_membership_id, $membership_type, $components = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetCharacter'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetCharacter'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetCharacter'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanAggregateStats
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20051
     */
    public function destiny2GetClanAggregateStats($group_id, $modes = null)
    {
        list($response) = $this->destiny2GetClanAggregateStatsWithHttpInfo($group_id, $modes);
        return $response;
    }

    /**
     * Operation destiny2GetClanAggregateStatsWithHttpInfo
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20051, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanAggregateStatsWithHttpInfo($group_id, $modes = null)
    {
        $request = $this->destiny2GetClanAggregateStatsRequest($group_id, $modes);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20051' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20051', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20051';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20051',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanAggregateStatsAsync
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanAggregateStatsAsync($group_id, $modes = null)
    {
        return $this->destiny2GetClanAggregateStatsAsyncWithHttpInfo($group_id, $modes)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanAggregateStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanAggregateStatsAsyncWithHttpInfo($group_id, $modes = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20051';
        $request = $this->destiny2GetClanAggregateStatsRequest($group_id, $modes);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanAggregateStats'
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetClanAggregateStatsRequest($group_id, $modes = null)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling destiny2GetClanAggregateStats'
            );
        }

        $resourcePath = '/Destiny2/Stats/AggregateClanStats/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanLeaderboards
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function destiny2GetClanLeaderboards($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetClanLeaderboardsWithHttpInfo($group_id, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetClanLeaderboardsWithHttpInfo
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanLeaderboardsWithHttpInfo($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetClanLeaderboardsRequest($group_id, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanLeaderboardsAsync
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanLeaderboardsAsync($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetClanLeaderboardsAsyncWithHttpInfo($group_id, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanLeaderboardsAsyncWithHttpInfo($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->destiny2GetClanLeaderboardsRequest($group_id, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanLeaderboards'
     *
     * @param  int $group_id Group ID of the clan whose leaderboards you wish to fetch. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetClanLeaderboardsRequest($group_id, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling destiny2GetClanLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/Clans/{groupId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($maxtop)) {
            $maxtop = ObjectSerializer::serializeCollection($maxtop, '', true);
        }
        if ($maxtop !== null) {
            $queryParams['maxtop'] = $maxtop;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($statid)) {
            $statid = ObjectSerializer::serializeCollection($statid, '', true);
        }
        if ($statid !== null) {
            $queryParams['statid'] = $statid;
        }


        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetClanWeeklyRewardState
     *
     * @param  int $group_id A valid group id of clan. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20040
     */
    public function destiny2GetClanWeeklyRewardState($group_id)
    {
        list($response) = $this->destiny2GetClanWeeklyRewardStateWithHttpInfo($group_id);
        return $response;
    }

    /**
     * Operation destiny2GetClanWeeklyRewardStateWithHttpInfo
     *
     * @param  int $group_id A valid group id of clan. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20040, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetClanWeeklyRewardStateWithHttpInfo($group_id)
    {
        $request = $this->destiny2GetClanWeeklyRewardStateRequest($group_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20040' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20040', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20040';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20040',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetClanWeeklyRewardStateAsync
     *
     * 
     *
     * @param  int $group_id A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanWeeklyRewardStateAsync($group_id)
    {
        return $this->destiny2GetClanWeeklyRewardStateAsyncWithHttpInfo($group_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetClanWeeklyRewardStateAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $group_id A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetClanWeeklyRewardStateAsyncWithHttpInfo($group_id)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20040';
        $request = $this->destiny2GetClanWeeklyRewardStateRequest($group_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetClanWeeklyRewardState'
     *
     * @param  int $group_id A valid group id of clan. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetClanWeeklyRewardStateRequest($group_id)
    {
        // verify the required parameter 'group_id' is set
        if ($group_id === null || (is_array($group_id) && count($group_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $group_id when calling destiny2GetClanWeeklyRewardState'
            );
        }

        $resourcePath = '/Destiny2/Clan/{groupId}/WeeklyRewardState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($group_id !== null) {
            $resourcePath = str_replace(
                '{' . 'groupId' . '}',
                ObjectSerializer::toPathValue($group_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetCollectibleNodeDetails
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectible_presentation_node_hash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20045
     */
    public function destiny2GetCollectibleNodeDetails($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components = null)
    {
        list($response) = $this->destiny2GetCollectibleNodeDetailsWithHttpInfo($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components);
        return $response;
    }

    /**
     * Operation destiny2GetCollectibleNodeDetailsWithHttpInfo
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectible_presentation_node_hash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20045, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetCollectibleNodeDetailsWithHttpInfo($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components = null)
    {
        $request = $this->destiny2GetCollectibleNodeDetailsRequest($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20045' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20045', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20045';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20045',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetCollectibleNodeDetailsAsync
     *
     * 
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectible_presentation_node_hash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCollectibleNodeDetailsAsync($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components = null)
    {
        return $this->destiny2GetCollectibleNodeDetailsAsyncWithHttpInfo($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetCollectibleNodeDetailsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectible_presentation_node_hash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetCollectibleNodeDetailsAsyncWithHttpInfo($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20045';
        $request = $this->destiny2GetCollectibleNodeDetailsRequest($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetCollectibleNodeDetails'
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting collectible detail info. (required)
     * @param  int $collectible_presentation_node_hash The hash identifier of the Presentation Node for whom we should return collectible details. Details will only be returned for collectibles that are direct descendants of this node. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetCollectibleNodeDetailsRequest($character_id, $collectible_presentation_node_hash, $destiny_membership_id, $membership_type, $components = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'collectible_presentation_node_hash' is set
        if ($collectible_presentation_node_hash === null || (is_array($collectible_presentation_node_hash) && count($collectible_presentation_node_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $collectible_presentation_node_hash when calling destiny2GetCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetCollectibleNodeDetails'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetCollectibleNodeDetails'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Collectibles/{collectiblePresentationNodeHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($collectible_presentation_node_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'collectiblePresentationNodeHash' . '}',
                ObjectSerializer::toPathValue($collectible_presentation_node_hash),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStats
     *
     * @param  int $character_id The specific character whose activities should be returned. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20057
     */
    public function destiny2GetDestinyAggregateActivityStats($character_id, $destiny_membership_id, $membership_type)
    {
        list($response) = $this->destiny2GetDestinyAggregateActivityStatsWithHttpInfo($character_id, $destiny_membership_id, $membership_type);
        return $response;
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStatsWithHttpInfo
     *
     * @param  int $character_id The specific character whose activities should be returned. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20057, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetDestinyAggregateActivityStatsWithHttpInfo($character_id, $destiny_membership_id, $membership_type)
    {
        $request = $this->destiny2GetDestinyAggregateActivityStatsRequest($character_id, $destiny_membership_id, $membership_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20057' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20057', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20057';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20057',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStatsAsync
     *
     * 
     *
     * @param  int $character_id The specific character whose activities should be returned. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyAggregateActivityStatsAsync($character_id, $destiny_membership_id, $membership_type)
    {
        return $this->destiny2GetDestinyAggregateActivityStatsAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetDestinyAggregateActivityStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The specific character whose activities should be returned. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyAggregateActivityStatsAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20057';
        $request = $this->destiny2GetDestinyAggregateActivityStatsRequest($character_id, $destiny_membership_id, $membership_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetDestinyAggregateActivityStats'
     *
     * @param  int $character_id The specific character whose activities should be returned. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetDestinyAggregateActivityStatsRequest($character_id, $destiny_membership_id, $membership_type)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetDestinyAggregateActivityStats'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetDestinyAggregateActivityStats'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/AggregateActivityStats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetDestinyEntityDefinition
     *
     * @param  string $entity_type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hash_identifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20035
     */
    public function destiny2GetDestinyEntityDefinition($entity_type, $hash_identifier)
    {
        list($response) = $this->destiny2GetDestinyEntityDefinitionWithHttpInfo($entity_type, $hash_identifier);
        return $response;
    }

    /**
     * Operation destiny2GetDestinyEntityDefinitionWithHttpInfo
     *
     * @param  string $entity_type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hash_identifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20035, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetDestinyEntityDefinitionWithHttpInfo($entity_type, $hash_identifier)
    {
        $request = $this->destiny2GetDestinyEntityDefinitionRequest($entity_type, $hash_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20035' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20035', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20035';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20035',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetDestinyEntityDefinitionAsync
     *
     * 
     *
     * @param  string $entity_type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hash_identifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyEntityDefinitionAsync($entity_type, $hash_identifier)
    {
        return $this->destiny2GetDestinyEntityDefinitionAsyncWithHttpInfo($entity_type, $hash_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetDestinyEntityDefinitionAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $entity_type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hash_identifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyEntityDefinitionAsyncWithHttpInfo($entity_type, $hash_identifier)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20035';
        $request = $this->destiny2GetDestinyEntityDefinitionRequest($entity_type, $hash_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetDestinyEntityDefinition'
     *
     * @param  string $entity_type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. PREVIEW: This endpoint is still in beta, and may experience rough edges. The schema is tentatively in final form, but there may be bugs that prevent desirable operation. (required)
     * @param  int $hash_identifier The hash identifier for the specific Entity you want returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetDestinyEntityDefinitionRequest($entity_type, $hash_identifier)
    {
        // verify the required parameter 'entity_type' is set
        if ($entity_type === null || (is_array($entity_type) && count($entity_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_type when calling destiny2GetDestinyEntityDefinition'
            );
        }
        // verify the required parameter 'hash_identifier' is set
        if ($hash_identifier === null || (is_array($hash_identifier) && count($hash_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash_identifier when calling destiny2GetDestinyEntityDefinition'
            );
        }

        $resourcePath = '/Destiny2/Manifest/{entityType}/{hashIdentifier}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entity_type !== null) {
            $resourcePath = str_replace(
                '{' . 'entityType' . '}',
                ObjectSerializer::toPathValue($entity_type),
                $resourcePath
            );
        }
        // path params
        if ($hash_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'hashIdentifier' . '}',
                ObjectSerializer::toPathValue($hash_identifier),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetDestinyManifest
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20034
     */
    public function destiny2GetDestinyManifest()
    {
        list($response) = $this->destiny2GetDestinyManifestWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2GetDestinyManifestWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20034, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetDestinyManifestWithHttpInfo()
    {
        $request = $this->destiny2GetDestinyManifestRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20034' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20034', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20034';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20034',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetDestinyManifestAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyManifestAsync()
    {
        return $this->destiny2GetDestinyManifestAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetDestinyManifestAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetDestinyManifestAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20034';
        $request = $this->destiny2GetDestinyManifestRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetDestinyManifest'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetDestinyManifestRequest()
    {

        $resourcePath = '/Destiny2/Manifest/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetHistoricalStats
     *
     * @param  int $character_id The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  int[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  int[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $period_type Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20053
     */
    public function destiny2GetHistoricalStats($character_id, $destiny_membership_id, $membership_type, $dayend = null, $daystart = null, $groups = null, $modes = null, $period_type = null)
    {
        list($response) = $this->destiny2GetHistoricalStatsWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $dayend, $daystart, $groups, $modes, $period_type);
        return $response;
    }

    /**
     * Operation destiny2GetHistoricalStatsWithHttpInfo
     *
     * @param  int $character_id The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  int[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  int[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $period_type Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20053, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetHistoricalStatsWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $dayend = null, $daystart = null, $groups = null, $modes = null, $period_type = null)
    {
        $request = $this->destiny2GetHistoricalStatsRequest($character_id, $destiny_membership_id, $membership_type, $dayend, $daystart, $groups, $modes, $period_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20053' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20053', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20053';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20053',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetHistoricalStatsAsync
     *
     * 
     *
     * @param  int $character_id The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  int[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  int[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $period_type Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsAsync($character_id, $destiny_membership_id, $membership_type, $dayend = null, $daystart = null, $groups = null, $modes = null, $period_type = null)
    {
        return $this->destiny2GetHistoricalStatsAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $dayend, $daystart, $groups, $modes, $period_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetHistoricalStatsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  int[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  int[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $period_type Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $dayend = null, $daystart = null, $groups = null, $modes = null, $period_type = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20053';
        $request = $this->destiny2GetHistoricalStatsRequest($character_id, $destiny_membership_id, $membership_type, $dayend, $daystart, $groups, $modes, $period_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetHistoricalStats'
     *
     * @param  int $character_id The id of the character to retrieve. You can omit this character ID or set it to 0 to get aggregate stats across all characters. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  \DateTime $dayend Last day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  \DateTime $daystart First day to return when daily stats are requested. Use the format YYYY-MM-DD. Currently, we cannot allow more than 31 days of daily data to be requested in a single request. (optional)
     * @param  int[] $groups Group of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals (optional)
     * @param  int[] $modes Game modes to return. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  int $period_type Indicates a specific period type to return. Optional. May be: Daily, AllTime, or Activity (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetHistoricalStatsRequest($character_id, $destiny_membership_id, $membership_type, $dayend = null, $daystart = null, $groups = null, $modes = null, $period_type = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetHistoricalStats'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetHistoricalStats'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetHistoricalStats'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($dayend)) {
            $dayend = ObjectSerializer::serializeCollection($dayend, '', true);
        }
        if ($dayend !== null) {
            $queryParams['dayend'] = $dayend;
        }
        // query params
        if (is_array($daystart)) {
            $daystart = ObjectSerializer::serializeCollection($daystart, '', true);
        }
        if ($daystart !== null) {
            $queryParams['daystart'] = $daystart;
        }
        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'form', true);
        }
        if ($groups !== null) {
            $queryParams['groups'] = $groups;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, 'form', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($period_type)) {
            $period_type = ObjectSerializer::serializeCollection($period_type, '', true);
        }
        if ($period_type !== null) {
            $queryParams['periodType'] = $period_type;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinition
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20049
     */
    public function destiny2GetHistoricalStatsDefinition()
    {
        list($response) = $this->destiny2GetHistoricalStatsDefinitionWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinitionWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20049, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetHistoricalStatsDefinitionWithHttpInfo()
    {
        $request = $this->destiny2GetHistoricalStatsDefinitionRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20049' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20049', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20049';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20049',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinitionAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsDefinitionAsync()
    {
        return $this->destiny2GetHistoricalStatsDefinitionAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetHistoricalStatsDefinitionAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsDefinitionAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20049';
        $request = $this->destiny2GetHistoricalStatsDefinitionRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetHistoricalStatsDefinition'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetHistoricalStatsDefinitionRequest()
    {

        $resourcePath = '/Destiny2/Stats/Definition/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccount
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20054
     */
    public function destiny2GetHistoricalStatsForAccount($destiny_membership_id, $membership_type, $groups = null)
    {
        list($response) = $this->destiny2GetHistoricalStatsForAccountWithHttpInfo($destiny_membership_id, $membership_type, $groups);
        return $response;
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccountWithHttpInfo
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20054, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetHistoricalStatsForAccountWithHttpInfo($destiny_membership_id, $membership_type, $groups = null)
    {
        $request = $this->destiny2GetHistoricalStatsForAccountRequest($destiny_membership_id, $membership_type, $groups);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20054' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20054', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20054';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20054',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccountAsync
     *
     * 
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsForAccountAsync($destiny_membership_id, $membership_type, $groups = null)
    {
        return $this->destiny2GetHistoricalStatsForAccountAsyncWithHttpInfo($destiny_membership_id, $membership_type, $groups)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetHistoricalStatsForAccountAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetHistoricalStatsForAccountAsyncWithHttpInfo($destiny_membership_id, $membership_type, $groups = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20054';
        $request = $this->destiny2GetHistoricalStatsForAccountRequest($destiny_membership_id, $membership_type, $groups);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetHistoricalStatsForAccount'
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $groups Groups of stats to include, otherwise only general stats are returned. Comma separated list is allowed. Values: General, Weapons, Medals. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetHistoricalStatsForAccountRequest($destiny_membership_id, $membership_type, $groups = null)
    {
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetHistoricalStatsForAccount'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetHistoricalStatsForAccount'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($groups)) {
            $groups = ObjectSerializer::serializeCollection($groups, 'form', true);
        }
        if ($groups !== null) {
            $queryParams['groups'] = $groups;
        }


        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetItem
     *
     * @param  int $destiny_membership_id The membership ID of the destiny profile. (required)
     * @param  int $item_instance_id The Instance ID of the destiny item. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20041
     */
    public function destiny2GetItem($destiny_membership_id, $item_instance_id, $membership_type, $components = null)
    {
        list($response) = $this->destiny2GetItemWithHttpInfo($destiny_membership_id, $item_instance_id, $membership_type, $components);
        return $response;
    }

    /**
     * Operation destiny2GetItemWithHttpInfo
     *
     * @param  int $destiny_membership_id The membership ID of the destiny profile. (required)
     * @param  int $item_instance_id The Instance ID of the destiny item. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetItemWithHttpInfo($destiny_membership_id, $item_instance_id, $membership_type, $components = null)
    {
        $request = $this->destiny2GetItemRequest($destiny_membership_id, $item_instance_id, $membership_type, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20041' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20041', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20041';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetItemAsync
     *
     * 
     *
     * @param  int $destiny_membership_id The membership ID of the destiny profile. (required)
     * @param  int $item_instance_id The Instance ID of the destiny item. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetItemAsync($destiny_membership_id, $item_instance_id, $membership_type, $components = null)
    {
        return $this->destiny2GetItemAsyncWithHttpInfo($destiny_membership_id, $item_instance_id, $membership_type, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetItemAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destiny_membership_id The membership ID of the destiny profile. (required)
     * @param  int $item_instance_id The Instance ID of the destiny item. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetItemAsyncWithHttpInfo($destiny_membership_id, $item_instance_id, $membership_type, $components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20041';
        $request = $this->destiny2GetItemRequest($destiny_membership_id, $item_instance_id, $membership_type, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetItem'
     *
     * @param  int $destiny_membership_id The membership ID of the destiny profile. (required)
     * @param  int $item_instance_id The Instance ID of the destiny item. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetItemRequest($destiny_membership_id, $item_instance_id, $membership_type, $components = null)
    {
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetItem'
            );
        }
        // verify the required parameter 'item_instance_id' is set
        if ($item_instance_id === null || (is_array($item_instance_id) && count($item_instance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_instance_id when calling destiny2GetItem'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetItem'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Item/{itemInstanceId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }


        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($item_instance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'itemInstanceId' . '}',
                ObjectSerializer::toPathValue($item_instance_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLeaderboards
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function destiny2GetLeaderboards($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetLeaderboardsWithHttpInfo($destiny_membership_id, $membership_type, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetLeaderboardsWithHttpInfo
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLeaderboardsWithHttpInfo($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetLeaderboardsRequest($destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLeaderboardsAsync
     *
     * 
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsAsync($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetLeaderboardsAsyncWithHttpInfo($destiny_membership_id, $membership_type, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLeaderboardsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsAsyncWithHttpInfo($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->destiny2GetLeaderboardsRequest($destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLeaderboards'
     *
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetLeaderboardsRequest($destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetLeaderboards'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetLeaderboards'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Stats/Leaderboards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($maxtop)) {
            $maxtop = ObjectSerializer::serializeCollection($maxtop, '', true);
        }
        if ($maxtop !== null) {
            $queryParams['maxtop'] = $maxtop;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($statid)) {
            $statid = ObjectSerializer::serializeCollection($statid, '', true);
        }
        if ($statid !== null) {
            $queryParams['statid'] = $statid;
        }


        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacter
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20050
     */
    public function destiny2GetLeaderboardsForCharacter($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        list($response) = $this->destiny2GetLeaderboardsForCharacterWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid);
        return $response;
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterWithHttpInfo
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20050, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLeaderboardsForCharacterWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $request = $this->destiny2GetLeaderboardsForCharacterRequest($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20050' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20050', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20050',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterAsync
     *
     * 
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsForCharacterAsync($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        return $this->destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLeaderboardsForCharacterAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20050';
        $request = $this->destiny2GetLeaderboardsForCharacterRequest($character_id, $destiny_membership_id, $membership_type, $maxtop, $modes, $statid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLeaderboardsForCharacter'
     *
     * @param  int $character_id The specific character to build the leaderboard around for the provided Destiny Membership. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $maxtop Maximum number of top players to return. Use a large number to get entire leaderboard. (optional)
     * @param  string $modes List of game modes for which to get leaderboards. See the documentation for DestinyActivityModeType for valid values, and pass in string representation, comma delimited. (optional)
     * @param  string $statid ID of stat to return rather than returning all Leaderboard stats. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetLeaderboardsForCharacterRequest($character_id, $destiny_membership_id, $membership_type, $maxtop = null, $modes = null, $statid = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetLeaderboardsForCharacter'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetLeaderboardsForCharacter'
            );
        }

        $resourcePath = '/Destiny2/Stats/Leaderboards/{membershipType}/{destinyMembershipId}/{characterId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($maxtop)) {
            $maxtop = ObjectSerializer::serializeCollection($maxtop, '', true);
        }
        if ($maxtop !== null) {
            $queryParams['maxtop'] = $maxtop;
        }
        // query params
        if (is_array($modes)) {
            $modes = ObjectSerializer::serializeCollection($modes, '', true);
        }
        if ($modes !== null) {
            $queryParams['modes'] = $modes;
        }
        // query params
        if (is_array($statid)) {
            $statid = ObjectSerializer::serializeCollection($statid, '', true);
        }
        if ($statid !== null) {
            $queryParams['statid'] = $statid;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetLinkedProfiles
     *
     * @param  int $membership_id The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membership_type The type for the membership whose linked Destiny accounts you want returned. (required)
     * @param  bool $get_all_memberships (optional) if set to &#39;true&#39;, all memberships regardless of whether they&#39;re obscured by overrides will be returned. Normal privacy restrictions on account linking will still apply no matter what. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20037
     */
    public function destiny2GetLinkedProfiles($membership_id, $membership_type, $get_all_memberships = null)
    {
        list($response) = $this->destiny2GetLinkedProfilesWithHttpInfo($membership_id, $membership_type, $get_all_memberships);
        return $response;
    }

    /**
     * Operation destiny2GetLinkedProfilesWithHttpInfo
     *
     * @param  int $membership_id The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membership_type The type for the membership whose linked Destiny accounts you want returned. (required)
     * @param  bool $get_all_memberships (optional) if set to &#39;true&#39;, all memberships regardless of whether they&#39;re obscured by overrides will be returned. Normal privacy restrictions on account linking will still apply no matter what. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20037, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetLinkedProfilesWithHttpInfo($membership_id, $membership_type, $get_all_memberships = null)
    {
        $request = $this->destiny2GetLinkedProfilesRequest($membership_id, $membership_type, $get_all_memberships);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20037' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20037', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20037';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetLinkedProfilesAsync
     *
     * 
     *
     * @param  int $membership_id The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membership_type The type for the membership whose linked Destiny accounts you want returned. (required)
     * @param  bool $get_all_memberships (optional) if set to &#39;true&#39;, all memberships regardless of whether they&#39;re obscured by overrides will be returned. Normal privacy restrictions on account linking will still apply no matter what. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLinkedProfilesAsync($membership_id, $membership_type, $get_all_memberships = null)
    {
        return $this->destiny2GetLinkedProfilesAsyncWithHttpInfo($membership_id, $membership_type, $get_all_memberships)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetLinkedProfilesAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $membership_id The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membership_type The type for the membership whose linked Destiny accounts you want returned. (required)
     * @param  bool $get_all_memberships (optional) if set to &#39;true&#39;, all memberships regardless of whether they&#39;re obscured by overrides will be returned. Normal privacy restrictions on account linking will still apply no matter what. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetLinkedProfilesAsyncWithHttpInfo($membership_id, $membership_type, $get_all_memberships = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20037';
        $request = $this->destiny2GetLinkedProfilesRequest($membership_id, $membership_type, $get_all_memberships);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetLinkedProfiles'
     *
     * @param  int $membership_id The ID of the membership whose linked Destiny accounts you want returned. Make sure your membership ID matches its Membership Type: don&#39;t pass us a PSN membership ID and the XBox membership type, it&#39;s not going to work! (required)
     * @param  int $membership_type The type for the membership whose linked Destiny accounts you want returned. (required)
     * @param  bool $get_all_memberships (optional) if set to &#39;true&#39;, all memberships regardless of whether they&#39;re obscured by overrides will be returned. Normal privacy restrictions on account linking will still apply no matter what. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetLinkedProfilesRequest($membership_id, $membership_type, $get_all_memberships = null)
    {
        // verify the required parameter 'membership_id' is set
        if ($membership_id === null || (is_array($membership_id) && count($membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_id when calling destiny2GetLinkedProfiles'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetLinkedProfiles'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{membershipId}/LinkedProfiles/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($get_all_memberships)) {
            $get_all_memberships = ObjectSerializer::serializeCollection($get_all_memberships, '', true);
        }
        if ($get_all_memberships !== null) {
            $queryParams['getAllMemberships'] = $get_all_memberships;
        }


        // path params
        if ($membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipId' . '}',
                ObjectSerializer::toPathValue($membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPostGameCarnageReport
     *
     * @param  int $activity_id The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20048
     */
    public function destiny2GetPostGameCarnageReport($activity_id)
    {
        list($response) = $this->destiny2GetPostGameCarnageReportWithHttpInfo($activity_id);
        return $response;
    }

    /**
     * Operation destiny2GetPostGameCarnageReportWithHttpInfo
     *
     * @param  int $activity_id The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20048, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPostGameCarnageReportWithHttpInfo($activity_id)
    {
        $request = $this->destiny2GetPostGameCarnageReportRequest($activity_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20048' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20048', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20048';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20048',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPostGameCarnageReportAsync
     *
     * 
     *
     * @param  int $activity_id The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPostGameCarnageReportAsync($activity_id)
    {
        return $this->destiny2GetPostGameCarnageReportAsyncWithHttpInfo($activity_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPostGameCarnageReportAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activity_id The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPostGameCarnageReportAsyncWithHttpInfo($activity_id)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20048';
        $request = $this->destiny2GetPostGameCarnageReportRequest($activity_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPostGameCarnageReport'
     *
     * @param  int $activity_id The ID of the activity whose PGCR is requested. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetPostGameCarnageReportRequest($activity_id)
    {
        // verify the required parameter 'activity_id' is set
        if ($activity_id === null || (is_array($activity_id) && count($activity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activity_id when calling destiny2GetPostGameCarnageReport'
            );
        }

        $resourcePath = '/Destiny2/Stats/PostGameCarnageReport/{activityId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($activity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'activityId' . '}',
                ObjectSerializer::toPathValue($activity_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetProfile
     *
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20038
     */
    public function destiny2GetProfile($destiny_membership_id, $membership_type, $components = null)
    {
        list($response) = $this->destiny2GetProfileWithHttpInfo($destiny_membership_id, $membership_type, $components);
        return $response;
    }

    /**
     * Operation destiny2GetProfileWithHttpInfo
     *
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetProfileWithHttpInfo($destiny_membership_id, $membership_type, $components = null)
    {
        $request = $this->destiny2GetProfileRequest($destiny_membership_id, $membership_type, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20038' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20038', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20038';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetProfileAsync
     *
     * 
     *
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetProfileAsync($destiny_membership_id, $membership_type, $components = null)
    {
        return $this->destiny2GetProfileAsyncWithHttpInfo($destiny_membership_id, $membership_type, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetProfileAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetProfileAsyncWithHttpInfo($destiny_membership_id, $membership_type, $components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20038';
        $request = $this->destiny2GetProfileRequest($destiny_membership_id, $membership_type, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetProfile'
     *
     * @param  int $destiny_membership_id Destiny membership ID. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetProfileRequest($destiny_membership_id, $membership_type, $components = null)
    {
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetProfile'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetProfile'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }


        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPublicMilestoneContent
     *
     * @param  int $milestone_hash The identifier for the milestone to be returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20058
     */
    public function destiny2GetPublicMilestoneContent($milestone_hash)
    {
        list($response) = $this->destiny2GetPublicMilestoneContentWithHttpInfo($milestone_hash);
        return $response;
    }

    /**
     * Operation destiny2GetPublicMilestoneContentWithHttpInfo
     *
     * @param  int $milestone_hash The identifier for the milestone to be returned. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20058, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPublicMilestoneContentWithHttpInfo($milestone_hash)
    {
        $request = $this->destiny2GetPublicMilestoneContentRequest($milestone_hash);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20058' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20058', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20058';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20058',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPublicMilestoneContentAsync
     *
     * 
     *
     * @param  int $milestone_hash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestoneContentAsync($milestone_hash)
    {
        return $this->destiny2GetPublicMilestoneContentAsyncWithHttpInfo($milestone_hash)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPublicMilestoneContentAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $milestone_hash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestoneContentAsyncWithHttpInfo($milestone_hash)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20058';
        $request = $this->destiny2GetPublicMilestoneContentRequest($milestone_hash);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPublicMilestoneContent'
     *
     * @param  int $milestone_hash The identifier for the milestone to be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetPublicMilestoneContentRequest($milestone_hash)
    {
        // verify the required parameter 'milestone_hash' is set
        if ($milestone_hash === null || (is_array($milestone_hash) && count($milestone_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $milestone_hash when calling destiny2GetPublicMilestoneContent'
            );
        }

        $resourcePath = '/Destiny2/Milestones/{milestoneHash}/Content/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($milestone_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'milestoneHash' . '}',
                ObjectSerializer::toPathValue($milestone_hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPublicMilestones
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20059
     */
    public function destiny2GetPublicMilestones()
    {
        list($response) = $this->destiny2GetPublicMilestonesWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2GetPublicMilestonesWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20059, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPublicMilestonesWithHttpInfo()
    {
        $request = $this->destiny2GetPublicMilestonesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20059' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20059', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20059';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20059',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPublicMilestonesAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestonesAsync()
    {
        return $this->destiny2GetPublicMilestonesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPublicMilestonesAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicMilestonesAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20059';
        $request = $this->destiny2GetPublicMilestonesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPublicMilestones'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetPublicMilestonesRequest()
    {

        $resourcePath = '/Destiny2/Milestones/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetPublicVendors
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20044
     */
    public function destiny2GetPublicVendors($components = null)
    {
        list($response) = $this->destiny2GetPublicVendorsWithHttpInfo($components);
        return $response;
    }

    /**
     * Operation destiny2GetPublicVendorsWithHttpInfo
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20044, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetPublicVendorsWithHttpInfo($components = null)
    {
        $request = $this->destiny2GetPublicVendorsRequest($components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20044' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20044', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20044';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20044',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetPublicVendorsAsync
     *
     * 
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicVendorsAsync($components = null)
    {
        return $this->destiny2GetPublicVendorsAsyncWithHttpInfo($components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetPublicVendorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetPublicVendorsAsyncWithHttpInfo($components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20044';
        $request = $this->destiny2GetPublicVendorsRequest($components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetPublicVendors'
     *
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetPublicVendorsRequest($components = null)
    {

        $resourcePath = '/Destiny2/Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetUniqueWeaponHistory
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20056
     */
    public function destiny2GetUniqueWeaponHistory($character_id, $destiny_membership_id, $membership_type)
    {
        list($response) = $this->destiny2GetUniqueWeaponHistoryWithHttpInfo($character_id, $destiny_membership_id, $membership_type);
        return $response;
    }

    /**
     * Operation destiny2GetUniqueWeaponHistoryWithHttpInfo
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20056, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetUniqueWeaponHistoryWithHttpInfo($character_id, $destiny_membership_id, $membership_type)
    {
        $request = $this->destiny2GetUniqueWeaponHistoryRequest($character_id, $destiny_membership_id, $membership_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20056' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20056', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20056';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20056',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetUniqueWeaponHistoryAsync
     *
     * 
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetUniqueWeaponHistoryAsync($character_id, $destiny_membership_id, $membership_type)
    {
        return $this->destiny2GetUniqueWeaponHistoryAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetUniqueWeaponHistoryAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetUniqueWeaponHistoryAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20056';
        $request = $this->destiny2GetUniqueWeaponHistoryRequest($character_id, $destiny_membership_id, $membership_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetUniqueWeaponHistory'
     *
     * @param  int $character_id The id of the character to retrieve. (required)
     * @param  int $destiny_membership_id The Destiny membershipId of the user to retrieve. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetUniqueWeaponHistoryRequest($character_id, $destiny_membership_id, $membership_type)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetUniqueWeaponHistory'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetUniqueWeaponHistory'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Account/{destinyMembershipId}/Character/{characterId}/Stats/UniqueWeapons/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetVendor
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $vendor_hash The Hash identifier of the Vendor to be returned. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20043
     */
    public function destiny2GetVendor($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components = null)
    {
        list($response) = $this->destiny2GetVendorWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components);
        return $response;
    }

    /**
     * Operation destiny2GetVendorWithHttpInfo
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $vendor_hash The Hash identifier of the Vendor to be returned. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20043, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetVendorWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components = null)
    {
        $request = $this->destiny2GetVendorRequest($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20043' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20043', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20043';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20043',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetVendorAsync
     *
     * 
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $vendor_hash The Hash identifier of the Vendor to be returned. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorAsync($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components = null)
    {
        return $this->destiny2GetVendorAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetVendorAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $vendor_hash The Hash identifier of the Vendor to be returned. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20043';
        $request = $this->destiny2GetVendorRequest($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetVendor'
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int $vendor_hash The Hash identifier of the Vendor to be returned. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetVendorRequest($character_id, $destiny_membership_id, $membership_type, $vendor_hash, $components = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetVendor'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetVendor'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetVendor'
            );
        }
        // verify the required parameter 'vendor_hash' is set
        if ($vendor_hash === null || (is_array($vendor_hash) && count($vendor_hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vendor_hash when calling destiny2GetVendor'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/{vendorHash}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }
        // path params
        if ($vendor_hash !== null) {
            $resourcePath = str_replace(
                '{' . 'vendorHash' . '}',
                ObjectSerializer::toPathValue($vendor_hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2GetVendors
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     * @param  int $filter The filter of what vendors and items to return, if any. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20042
     */
    public function destiny2GetVendors($character_id, $destiny_membership_id, $membership_type, $components = null, $filter = null)
    {
        list($response) = $this->destiny2GetVendorsWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components, $filter);
        return $response;
    }

    /**
     * Operation destiny2GetVendorsWithHttpInfo
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     * @param  int $filter The filter of what vendors and items to return, if any. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20042, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2GetVendorsWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components = null, $filter = null)
    {
        $request = $this->destiny2GetVendorsRequest($character_id, $destiny_membership_id, $membership_type, $components, $filter);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20042' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20042', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20042';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20042',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2GetVendorsAsync
     *
     * 
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     * @param  int $filter The filter of what vendors and items to return, if any. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorsAsync($character_id, $destiny_membership_id, $membership_type, $components = null, $filter = null)
    {
        return $this->destiny2GetVendorsAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components, $filter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2GetVendorsAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     * @param  int $filter The filter of what vendors and items to return, if any. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2GetVendorsAsyncWithHttpInfo($character_id, $destiny_membership_id, $membership_type, $components = null, $filter = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20042';
        $request = $this->destiny2GetVendorsRequest($character_id, $destiny_membership_id, $membership_type, $components, $filter);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2GetVendors'
     *
     * @param  int $character_id The Destiny Character ID of the character for whom we&#39;re getting vendor info. (required)
     * @param  int $destiny_membership_id Destiny membership ID of another user. You may be denied. (required)
     * @param  int $membership_type A valid non-BungieNet membership type. (required)
     * @param  int[] $components A comma separated list of components to return (as strings or numeric values). See the DestinyComponentType enum for valid components to request. You must request at least one component to receive results. (optional)
     * @param  int $filter The filter of what vendors and items to return, if any. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2GetVendorsRequest($character_id, $destiny_membership_id, $membership_type, $components = null, $filter = null)
    {
        // verify the required parameter 'character_id' is set
        if ($character_id === null || (is_array($character_id) && count($character_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $character_id when calling destiny2GetVendors'
            );
        }
        // verify the required parameter 'destiny_membership_id' is set
        if ($destiny_membership_id === null || (is_array($destiny_membership_id) && count($destiny_membership_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destiny_membership_id when calling destiny2GetVendors'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2GetVendors'
            );
        }

        $resourcePath = '/Destiny2/{membershipType}/Profile/{destinyMembershipId}/Character/{characterId}/Vendors/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($components)) {
            $components = ObjectSerializer::serializeCollection($components, 'form', true);
        }
        if ($components !== null) {
            $queryParams['components'] = $components;
        }
        // query params
        if (is_array($filter)) {
            $filter = ObjectSerializer::serializeCollection($filter, '', true);
        }
        if ($filter !== null) {
            $queryParams['filter'] = $filter;
        }


        // path params
        if ($character_id !== null) {
            $resourcePath = str_replace(
                '{' . 'characterId' . '}',
                ObjectSerializer::toPathValue($character_id),
                $resourcePath
            );
        }
        // path params
        if ($destiny_membership_id !== null) {
            $resourcePath = str_replace(
                '{' . 'destinyMembershipId' . '}',
                ObjectSerializer::toPathValue($destiny_membership_id),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2InsertSocketPlug
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20047
     */
    public function destiny2InsertSocketPlug()
    {
        list($response) = $this->destiny2InsertSocketPlugWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2InsertSocketPlugWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20047, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2InsertSocketPlugWithHttpInfo()
    {
        $request = $this->destiny2InsertSocketPlugRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20047' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20047', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20047';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20047',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2InsertSocketPlugAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2InsertSocketPlugAsync()
    {
        return $this->destiny2InsertSocketPlugAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2InsertSocketPlugAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2InsertSocketPlugAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20047';
        $request = $this->destiny2InsertSocketPlugRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2InsertSocketPlug'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2InsertSocketPlugRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/InsertSocketPlug/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2PullFromPostmaster
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2PullFromPostmaster()
    {
        list($response) = $this->destiny2PullFromPostmasterWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2PullFromPostmasterWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2PullFromPostmasterWithHttpInfo()
    {
        $request = $this->destiny2PullFromPostmasterRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2PullFromPostmasterAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2PullFromPostmasterAsync()
    {
        return $this->destiny2PullFromPostmasterAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2PullFromPostmasterAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2PullFromPostmasterAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2PullFromPostmasterRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2PullFromPostmaster'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2PullFromPostmasterRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/PullFromPostmaster/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayer
     *
     * @param  int $activity_id The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayer($activity_id)
    {
        list($response) = $this->destiny2ReportOffensivePostGameCarnageReportPlayerWithHttpInfo($activity_id);
        return $response;
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayerWithHttpInfo
     *
     * @param  int $activity_id The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerWithHttpInfo($activity_id)
    {
        $request = $this->destiny2ReportOffensivePostGameCarnageReportPlayerRequest($activity_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayerAsync
     *
     * 
     *
     * @param  int $activity_id The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerAsync($activity_id)
    {
        return $this->destiny2ReportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo($activity_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2ReportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $activity_id The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerAsyncWithHttpInfo($activity_id)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2ReportOffensivePostGameCarnageReportPlayerRequest($activity_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2ReportOffensivePostGameCarnageReportPlayer'
     *
     * @param  int $activity_id The ID of the activity where you ran into the brigand that you&#39;re reporting. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2ReportOffensivePostGameCarnageReportPlayerRequest($activity_id)
    {
        // verify the required parameter 'activity_id' is set
        if ($activity_id === null || (is_array($activity_id) && count($activity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $activity_id when calling destiny2ReportOffensivePostGameCarnageReportPlayer'
            );
        }

        $resourcePath = '/Destiny2/Stats/PostGameCarnageReport/{activityId}/Report/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($activity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'activityId' . '}',
                ObjectSerializer::toPathValue($activity_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SearchDestinyEntities
     *
     * @param  string $search_term The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20052
     */
    public function destiny2SearchDestinyEntities($search_term, $type, $page = null)
    {
        list($response) = $this->destiny2SearchDestinyEntitiesWithHttpInfo($search_term, $type, $page);
        return $response;
    }

    /**
     * Operation destiny2SearchDestinyEntitiesWithHttpInfo
     *
     * @param  string $search_term The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20052, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SearchDestinyEntitiesWithHttpInfo($search_term, $type, $page = null)
    {
        $request = $this->destiny2SearchDestinyEntitiesRequest($search_term, $type, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20052' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20052', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20052';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20052',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SearchDestinyEntitiesAsync
     *
     * 
     *
     * @param  string $search_term The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyEntitiesAsync($search_term, $type, $page = null)
    {
        return $this->destiny2SearchDestinyEntitiesAsyncWithHttpInfo($search_term, $type, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SearchDestinyEntitiesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $search_term The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyEntitiesAsyncWithHttpInfo($search_term, $type, $page = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20052';
        $request = $this->destiny2SearchDestinyEntitiesRequest($search_term, $type, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SearchDestinyEntities'
     *
     * @param  string $search_term The string to use when searching for Destiny entities. (required)
     * @param  string $type The type of entity for whom you would like results. These correspond to the entity&#39;s definition contract name. For instance, if you are looking for items, this property should be &#39;DestinyInventoryItemDefinition&#39;. (required)
     * @param  int $page Page number to return, starting with 0. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2SearchDestinyEntitiesRequest($search_term, $type, $page = null)
    {
        // verify the required parameter 'search_term' is set
        if ($search_term === null || (is_array($search_term) && count($search_term) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_term when calling destiny2SearchDestinyEntities'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling destiny2SearchDestinyEntities'
            );
        }

        $resourcePath = '/Destiny2/Armory/Search/{type}/{searchTerm}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($page)) {
            $page = ObjectSerializer::serializeCollection($page, '', true);
        }
        if ($page !== null) {
            $queryParams['page'] = $page;
        }


        // path params
        if ($search_term !== null) {
            $resourcePath = str_replace(
                '{' . 'searchTerm' . '}',
                ObjectSerializer::toPathValue($search_term),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SearchDestinyPlayer
     *
     * @param  string $display_name The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membership_type A valid non-BungieNet membership type, or All. (required)
     * @param  bool $return_original_profile (optional) If passed in and set to true, we will return the original Destiny Profile(s) linked to that gamertag, and not their currently active Destiny Profile. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20036
     */
    public function destiny2SearchDestinyPlayer($display_name, $membership_type, $return_original_profile = null)
    {
        list($response) = $this->destiny2SearchDestinyPlayerWithHttpInfo($display_name, $membership_type, $return_original_profile);
        return $response;
    }

    /**
     * Operation destiny2SearchDestinyPlayerWithHttpInfo
     *
     * @param  string $display_name The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membership_type A valid non-BungieNet membership type, or All. (required)
     * @param  bool $return_original_profile (optional) If passed in and set to true, we will return the original Destiny Profile(s) linked to that gamertag, and not their currently active Destiny Profile. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SearchDestinyPlayerWithHttpInfo($display_name, $membership_type, $return_original_profile = null)
    {
        $request = $this->destiny2SearchDestinyPlayerRequest($display_name, $membership_type, $return_original_profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20036' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20036', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20036';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SearchDestinyPlayerAsync
     *
     * 
     *
     * @param  string $display_name The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membership_type A valid non-BungieNet membership type, or All. (required)
     * @param  bool $return_original_profile (optional) If passed in and set to true, we will return the original Destiny Profile(s) linked to that gamertag, and not their currently active Destiny Profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyPlayerAsync($display_name, $membership_type, $return_original_profile = null)
    {
        return $this->destiny2SearchDestinyPlayerAsyncWithHttpInfo($display_name, $membership_type, $return_original_profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SearchDestinyPlayerAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $display_name The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membership_type A valid non-BungieNet membership type, or All. (required)
     * @param  bool $return_original_profile (optional) If passed in and set to true, we will return the original Destiny Profile(s) linked to that gamertag, and not their currently active Destiny Profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SearchDestinyPlayerAsyncWithHttpInfo($display_name, $membership_type, $return_original_profile = null)
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20036';
        $request = $this->destiny2SearchDestinyPlayerRequest($display_name, $membership_type, $return_original_profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SearchDestinyPlayer'
     *
     * @param  string $display_name The full gamertag or PSN id of the player. Spaces and case are ignored. (required)
     * @param  int $membership_type A valid non-BungieNet membership type, or All. (required)
     * @param  bool $return_original_profile (optional) If passed in and set to true, we will return the original Destiny Profile(s) linked to that gamertag, and not their currently active Destiny Profile. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2SearchDestinyPlayerRequest($display_name, $membership_type, $return_original_profile = null)
    {
        // verify the required parameter 'display_name' is set
        if ($display_name === null || (is_array($display_name) && count($display_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $display_name when calling destiny2SearchDestinyPlayer'
            );
        }
        // verify the required parameter 'membership_type' is set
        if ($membership_type === null || (is_array($membership_type) && count($membership_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $membership_type when calling destiny2SearchDestinyPlayer'
            );
        }

        $resourcePath = '/Destiny2/SearchDestinyPlayer/{membershipType}/{displayName}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($return_original_profile)) {
            $return_original_profile = ObjectSerializer::serializeCollection($return_original_profile, '', true);
        }
        if ($return_original_profile !== null) {
            $queryParams['returnOriginalProfile'] = $return_original_profile;
        }


        // path params
        if ($display_name !== null) {
            $resourcePath = str_replace(
                '{' . 'displayName' . '}',
                ObjectSerializer::toPathValue($display_name),
                $resourcePath
            );
        }
        // path params
        if ($membership_type !== null) {
            $resourcePath = str_replace(
                '{' . 'membershipType' . '}',
                ObjectSerializer::toPathValue($membership_type),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SetItemLockState
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2SetItemLockState()
    {
        list($response) = $this->destiny2SetItemLockStateWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2SetItemLockStateWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SetItemLockStateWithHttpInfo()
    {
        $request = $this->destiny2SetItemLockStateRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SetItemLockStateAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SetItemLockStateAsync()
    {
        return $this->destiny2SetItemLockStateAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SetItemLockStateAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SetItemLockStateAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2SetItemLockStateRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SetItemLockState'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2SetItemLockStateRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/SetLockState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2SetQuestTrackedState
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2SetQuestTrackedState()
    {
        list($response) = $this->destiny2SetQuestTrackedStateWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2SetQuestTrackedStateWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2SetQuestTrackedStateWithHttpInfo()
    {
        $request = $this->destiny2SetQuestTrackedStateRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2SetQuestTrackedStateAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SetQuestTrackedStateAsync()
    {
        return $this->destiny2SetQuestTrackedStateAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2SetQuestTrackedStateAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2SetQuestTrackedStateAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2SetQuestTrackedStateRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2SetQuestTrackedState'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2SetQuestTrackedStateRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/SetTrackedState/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destiny2TransferItem
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineResponse20023
     */
    public function destiny2TransferItem()
    {
        list($response) = $this->destiny2TransferItemWithHttpInfo();
        return $response;
    }

    /**
     * Operation destiny2TransferItemWithHttpInfo
     *
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function destiny2TransferItemWithHttpInfo()
    {
        $request = $this->destiny2TransferItemRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\InlineResponse20023' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InlineResponse20023', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation destiny2TransferItemAsync
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2TransferItemAsync()
    {
        return $this->destiny2TransferItemAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destiny2TransferItemAsyncWithHttpInfo
     *
     * 
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destiny2TransferItemAsyncWithHttpInfo()
    {
        $returnType = '\OpenAPI\Client\Model\InlineResponse20023';
        $request = $this->destiny2TransferItemRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destiny2TransferItem'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function destiny2TransferItemRequest()
    {

        $resourcePath = '/Destiny2/Actions/Items/TransferItem/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
