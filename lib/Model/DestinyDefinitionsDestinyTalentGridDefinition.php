<?php
/**
 * DestinyDefinitionsDestinyTalentGridDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyTalentGridDefinition Class Doc Comment
 *
 * @category Class
 * @description The time has unfortunately come to talk about Talent Grids.  Talent Grids are the most complex and unintuitive part of the Destiny Definition data. Grab a cup of coffee before we begin, I can wait.  Talent Grids were the primary way that items could be customized in Destiny 1. In Destiny 2, for now, talent grids have become exclusively used by Subclass/Build items: but the system is still in place for it to be used by items should the direction change back toward talent grids.  Talent Grids have Nodes: the visual circles on the talent grid detail screen that have icons and can be activated if you meet certain requirements and pay costs. The actual visual data and effects, however, are driven by the \&quot;Steps\&quot; on Talent Nodes. Any given node will have 1:M of these steps, and the specific step that will be considered the \&quot;current\&quot; step (and thus the dictator of all benefits, visual state, and activation requirements on the Node) will almost always not be determined until an instance of the item is created. This is how, in Destiny 1, items were able to have such a wide variety of what users saw as \&quot;Perks\&quot;: they were actually Talent Grids with nodes that had a wide variety of Steps, randomly chosen at the time of item creation.  Now that Talent Grids are used exclusively by subclasses and builds, all of the properties within still apply: but there are additional visual elements on the Subclass/Build screens that are superimposed on top of the talent nodes. Unfortunately, BNet doesn&#39;t have this data: if you want to build a subclass screen, you will have to provide your own \&quot;decorative\&quot; assets, such as the visual connectors between nodes and the fancy colored-fire-bathed character standing behind the nodes.  DestinyInventoryItem.talentGrid.talentGridHash defines an item&#39;s linked Talent Grid, which brings you to this definition that contains enough satic data about talent grids to make your head spin. These *must* be combined with instanced data - found when live data returns DestinyItemTalentGridComponent - in order to derive meaning. The instanced data will reference nodes and steps within these definitions, which you will then have to look up in the definition and combine with the instanced data to give the user the visual representation of their item&#39;s talent grid.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyTalentGridDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyTalentGridDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'max_grid_level' => 'int',
        'grid_level_per_column' => 'int',
        'progression_hash' => 'int',
        'nodes' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeDefinition[]',
        'exclusive_sets' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition[]',
        'independent_node_indexes' => 'int[]',
        'groups' => 'map[string,\OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentExclusiveGroup]',
        'node_categories' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeCategory[]',
        'hash' => 'int',
        'index' => 'int',
        'redacted' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'max_grid_level' => 'int32',
        'grid_level_per_column' => 'int32',
        'progression_hash' => 'uint32',
        'nodes' => null,
        'exclusive_sets' => null,
        'independent_node_indexes' => 'int32',
        'groups' => null,
        'node_categories' => null,
        'hash' => 'uint32',
        'index' => 'int32',
        'redacted' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'max_grid_level' => 'maxGridLevel',
        'grid_level_per_column' => 'gridLevelPerColumn',
        'progression_hash' => 'progressionHash',
        'nodes' => 'nodes',
        'exclusive_sets' => 'exclusiveSets',
        'independent_node_indexes' => 'independentNodeIndexes',
        'groups' => 'groups',
        'node_categories' => 'nodeCategories',
        'hash' => 'hash',
        'index' => 'index',
        'redacted' => 'redacted'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'max_grid_level' => 'setMaxGridLevel',
        'grid_level_per_column' => 'setGridLevelPerColumn',
        'progression_hash' => 'setProgressionHash',
        'nodes' => 'setNodes',
        'exclusive_sets' => 'setExclusiveSets',
        'independent_node_indexes' => 'setIndependentNodeIndexes',
        'groups' => 'setGroups',
        'node_categories' => 'setNodeCategories',
        'hash' => 'setHash',
        'index' => 'setIndex',
        'redacted' => 'setRedacted'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'max_grid_level' => 'getMaxGridLevel',
        'grid_level_per_column' => 'getGridLevelPerColumn',
        'progression_hash' => 'getProgressionHash',
        'nodes' => 'getNodes',
        'exclusive_sets' => 'getExclusiveSets',
        'independent_node_indexes' => 'getIndependentNodeIndexes',
        'groups' => 'getGroups',
        'node_categories' => 'getNodeCategories',
        'hash' => 'getHash',
        'index' => 'getIndex',
        'redacted' => 'getRedacted'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['max_grid_level'] = $data['max_grid_level'] ?? null;
        $this->container['grid_level_per_column'] = $data['grid_level_per_column'] ?? null;
        $this->container['progression_hash'] = $data['progression_hash'] ?? null;
        $this->container['nodes'] = $data['nodes'] ?? null;
        $this->container['exclusive_sets'] = $data['exclusive_sets'] ?? null;
        $this->container['independent_node_indexes'] = $data['independent_node_indexes'] ?? null;
        $this->container['groups'] = $data['groups'] ?? null;
        $this->container['node_categories'] = $data['node_categories'] ?? null;
        $this->container['hash'] = $data['hash'] ?? null;
        $this->container['index'] = $data['index'] ?? null;
        $this->container['redacted'] = $data['redacted'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets max_grid_level
     *
     * @return int|null
     */
    public function getMaxGridLevel()
    {
        return $this->container['max_grid_level'];
    }

    /**
     * Sets max_grid_level
     *
     * @param int|null $max_grid_level The maximum possible level of the Talent Grid: at this level, any nodes are allowed to be activated.
     *
     * @return self
     */
    public function setMaxGridLevel($max_grid_level)
    {
        $this->container['max_grid_level'] = $max_grid_level;

        return $this;
    }

    /**
     * Gets grid_level_per_column
     *
     * @return int|null
     */
    public function getGridLevelPerColumn()
    {
        return $this->container['grid_level_per_column'];
    }

    /**
     * Sets grid_level_per_column
     *
     * @param int|null $grid_level_per_column The meaning of this has been lost in the sands of time: it still exists as a property, but appears to be unused in the modern UI of talent grids. It used to imply that each visual \"column\" of talent nodes required identical progression levels in order to be activated. Returning this value in case it is still useful to someone? Perhaps it's just a bit of interesting history.
     *
     * @return self
     */
    public function setGridLevelPerColumn($grid_level_per_column)
    {
        $this->container['grid_level_per_column'] = $grid_level_per_column;

        return $this;
    }

    /**
     * Gets progression_hash
     *
     * @return int|null
     */
    public function getProgressionHash()
    {
        return $this->container['progression_hash'];
    }

    /**
     * Sets progression_hash
     *
     * @param int|null $progression_hash The hash identifier of the Progression (DestinyProgressionDefinition) that drives whether and when Talent Nodes can be activated on the Grid. Items will have instances of this Progression, and will gain experience that will eventually cause the grid to increase in level. As the grid's level increases, it will cross the threshold where nodes can be activated. See DestinyTalentGridStepDefinition's activation requirements for more information.
     *
     * @return self
     */
    public function setProgressionHash($progression_hash)
    {
        $this->container['progression_hash'] = $progression_hash;

        return $this;
    }

    /**
     * Gets nodes
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeDefinition[]|null
     */
    public function getNodes()
    {
        return $this->container['nodes'];
    }

    /**
     * Sets nodes
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeDefinition[]|null $nodes The list of Talent Nodes on the Grid (recall that Nodes themselves are really just locations in the UI to show whatever their current Step is. You will only know the current step for a node by retrieving instanced data through platform calls to the API that return DestinyItemTalentGridComponent).
     *
     * @return self
     */
    public function setNodes($nodes)
    {
        $this->container['nodes'] = $nodes;

        return $this;
    }

    /**
     * Gets exclusive_sets
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition[]|null
     */
    public function getExclusiveSets()
    {
        return $this->container['exclusive_sets'];
    }

    /**
     * Sets exclusive_sets
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeExclusiveSetDefinition[]|null $exclusive_sets Talent Nodes can exist in \"exclusive sets\": these are sets of nodes in which only a single node in the set can be activated at any given time. Activating a node in this set will automatically deactivate the other nodes in the set (referred to as a \"Swap\").  If a node in the exclusive set has already been activated, the game will not charge you materials to activate another node in the set, even if you have never activated it before, because you already paid the cost to activate one node in the set.  Not to be confused with Exclusive Groups. (how the heck do we NOT get confused by that? Jeez) See the groups property for information about that only-tangentially-related concept.
     *
     * @return self
     */
    public function setExclusiveSets($exclusive_sets)
    {
        $this->container['exclusive_sets'] = $exclusive_sets;

        return $this;
    }

    /**
     * Gets independent_node_indexes
     *
     * @return int[]|null
     */
    public function getIndependentNodeIndexes()
    {
        return $this->container['independent_node_indexes'];
    }

    /**
     * Sets independent_node_indexes
     *
     * @param int[]|null $independent_node_indexes This is a quick reference to the indexes of nodes that are not part of exclusive sets. Handy for knowing which talent nodes can only be activated directly, rather than via swapping.
     *
     * @return self
     */
    public function setIndependentNodeIndexes($independent_node_indexes)
    {
        $this->container['independent_node_indexes'] = $independent_node_indexes;

        return $this;
    }

    /**
     * Gets groups
     *
     * @return map[string,\OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentExclusiveGroup]|null
     */
    public function getGroups()
    {
        return $this->container['groups'];
    }

    /**
     * Sets groups
     *
     * @param map[string,\OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentExclusiveGroup]|null $groups Talent Nodes can have \"Exclusive Groups\". These are not to be confused with Exclusive Sets (see exclusiveSets property).  Look at the definition of DestinyTalentExclusiveGroup for more information and how they work. These groups are keyed by the \"groupHash\" from DestinyTalentExclusiveGroup.
     *
     * @return self
     */
    public function setGroups($groups)
    {
        $this->container['groups'] = $groups;

        return $this;
    }

    /**
     * Gets node_categories
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeCategory[]|null
     */
    public function getNodeCategories()
    {
        return $this->container['node_categories'];
    }

    /**
     * Sets node_categories
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyTalentNodeCategory[]|null $node_categories BNet wants to show talent nodes grouped by similar purpose with localized titles. This is the ordered list of those categories: if you want to show nodes by category, you can iterate over this list, render the displayProperties for the category as the title, and then iterate over the talent nodes referenced by the category to show the related nodes.  Note that this is different from Exclusive Groups or Sets, because these categories also incorporate \"Independent\" nodes that belong to neither sets nor groups. These are purely for visual grouping of nodes rather than functional grouping.
     *
     * @return self
     */
    public function setNodeCategories($node_categories)
    {
        $this->container['node_categories'] = $node_categories;

        return $this;
    }

    /**
     * Gets hash
     *
     * @return int|null
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param int|null $hash The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
     *
     * @return self
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets index
     *
     * @return int|null
     */
    public function getIndex()
    {
        return $this->container['index'];
    }

    /**
     * Sets index
     *
     * @param int|null $index The index of the entity as it was found in the investment tables.
     *
     * @return self
     */
    public function setIndex($index)
    {
        $this->container['index'] = $index;

        return $this;
    }

    /**
     * Gets redacted
     *
     * @return bool|null
     */
    public function getRedacted()
    {
        return $this->container['redacted'];
    }

    /**
     * Sets redacted
     *
     * @param bool|null $redacted If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
     *
     * @return self
     */
    public function setRedacted($redacted)
    {
        $this->container['redacted'] = $redacted;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


