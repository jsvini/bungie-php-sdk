<?php
/**
 * DestinyMilestonesDestinyMilestone
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyMilestonesDestinyMilestone Class Doc Comment
 *
 * @category Class
 * @description Represents a runtime instance of a user&#39;s milestone status. Live Milestone data should be combined with DestinyMilestoneDefinition data to show the user a picture of what is available for them to do in the game, and their status in regards to said \&quot;things to do.\&quot; Consider it a big, wonky to-do list, or Advisors 3.0 for those who remember the Destiny 1 API.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyMilestonesDestinyMilestone implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Milestones.DestinyMilestone';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'milestone_hash' => 'int',
        'available_quests' => '\OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneQuest[]',
        'activities' => '\OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneChallengeActivity[]',
        'values' => 'map[string,float]',
        'vendor_hashes' => 'int[]',
        'vendors' => '\OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneVendor[]',
        'rewards' => '\OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneRewardCategory[]',
        'start_date' => '\DateTime',
        'end_date' => '\DateTime',
        'order' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'milestone_hash' => 'uint32',
        'available_quests' => null,
        'activities' => null,
        'values' => 'float',
        'vendor_hashes' => 'uint32',
        'vendors' => null,
        'rewards' => null,
        'start_date' => 'date-time',
        'end_date' => 'date-time',
        'order' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'milestone_hash' => 'milestoneHash',
        'available_quests' => 'availableQuests',
        'activities' => 'activities',
        'values' => 'values',
        'vendor_hashes' => 'vendorHashes',
        'vendors' => 'vendors',
        'rewards' => 'rewards',
        'start_date' => 'startDate',
        'end_date' => 'endDate',
        'order' => 'order'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'milestone_hash' => 'setMilestoneHash',
        'available_quests' => 'setAvailableQuests',
        'activities' => 'setActivities',
        'values' => 'setValues',
        'vendor_hashes' => 'setVendorHashes',
        'vendors' => 'setVendors',
        'rewards' => 'setRewards',
        'start_date' => 'setStartDate',
        'end_date' => 'setEndDate',
        'order' => 'setOrder'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'milestone_hash' => 'getMilestoneHash',
        'available_quests' => 'getAvailableQuests',
        'activities' => 'getActivities',
        'values' => 'getValues',
        'vendor_hashes' => 'getVendorHashes',
        'vendors' => 'getVendors',
        'rewards' => 'getRewards',
        'start_date' => 'getStartDate',
        'end_date' => 'getEndDate',
        'order' => 'getOrder'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['milestone_hash'] = $data['milestone_hash'] ?? null;
        $this->container['available_quests'] = $data['available_quests'] ?? null;
        $this->container['activities'] = $data['activities'] ?? null;
        $this->container['values'] = $data['values'] ?? null;
        $this->container['vendor_hashes'] = $data['vendor_hashes'] ?? null;
        $this->container['vendors'] = $data['vendors'] ?? null;
        $this->container['rewards'] = $data['rewards'] ?? null;
        $this->container['start_date'] = $data['start_date'] ?? null;
        $this->container['end_date'] = $data['end_date'] ?? null;
        $this->container['order'] = $data['order'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets milestone_hash
     *
     * @return int|null
     */
    public function getMilestoneHash()
    {
        return $this->container['milestone_hash'];
    }

    /**
     * Sets milestone_hash
     *
     * @param int|null $milestone_hash The unique identifier for the Milestone. Use it to look up the DestinyMilestoneDefinition, so you can combine the other data in this contract with static definition data.
     *
     * @return self
     */
    public function setMilestoneHash($milestone_hash)
    {
        $this->container['milestone_hash'] = $milestone_hash;

        return $this;
    }

    /**
     * Gets available_quests
     *
     * @return \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneQuest[]|null
     */
    public function getAvailableQuests()
    {
        return $this->container['available_quests'];
    }

    /**
     * Sets available_quests
     *
     * @param \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneQuest[]|null $available_quests Indicates what quests are available for this Milestone. Usually this will be only a single Quest, but some quests have multiple available that you can choose from at any given time. All possible quests for a milestone can be found in the DestinyMilestoneDefinition, but they must be combined with this Live data to determine which one(s) are actually active right now. It is possible for Milestones to not have any quests.
     *
     * @return self
     */
    public function setAvailableQuests($available_quests)
    {
        $this->container['available_quests'] = $available_quests;

        return $this;
    }

    /**
     * Gets activities
     *
     * @return \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneChallengeActivity[]|null
     */
    public function getActivities()
    {
        return $this->container['activities'];
    }

    /**
     * Sets activities
     *
     * @param \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneChallengeActivity[]|null $activities The currently active Activities in this milestone, when the Milestone is driven by Challenges.  Not all Milestones have Challenges, but when they do this will indicate the Activities and Challenges under those Activities related to this Milestone.
     *
     * @return self
     */
    public function setActivities($activities)
    {
        $this->container['activities'] = $activities;

        return $this;
    }

    /**
     * Gets values
     *
     * @return map[string,float]|null
     */
    public function getValues()
    {
        return $this->container['values'];
    }

    /**
     * Sets values
     *
     * @param map[string,float]|null $values Milestones may have arbitrary key/value pairs associated with them, for data that users will want to know about but that doesn't fit neatly into any of the common components such as Quests. A good example of this would be - if this existed in Destiny 1 - the number of wins you currently have on your Trials of Osiris ticket. Looking in the DestinyMilestoneDefinition, you can use the string identifier of this dictionary to look up more info about the value, including localized string content for displaying the value. The value in the dictionary is the floating point number. The definition will tell you how to format this number.
     *
     * @return self
     */
    public function setValues($values)
    {
        $this->container['values'] = $values;

        return $this;
    }

    /**
     * Gets vendor_hashes
     *
     * @return int[]|null
     */
    public function getVendorHashes()
    {
        return $this->container['vendor_hashes'];
    }

    /**
     * Sets vendor_hashes
     *
     * @param int[]|null $vendor_hashes A milestone may have one or more active vendors that are \"related\" to it (that provide rewards, or that are the initiators of the Milestone). I already regret this, even as I'm typing it. [I told you I'd regret this] You see, sometimes a milestone may be directly correlated with a set of vendors that provide varying tiers of rewards. The player may not be able to interact with one or more of those vendors. This will return the hashes of the Vendors that the player *can* interact with, allowing you to show their current inventory as rewards or related items to the Milestone or its activities.  Before we even use it, it's already deprecated! How much of a bummer is that? We need more data.
     *
     * @return self
     */
    public function setVendorHashes($vendor_hashes)
    {
        $this->container['vendor_hashes'] = $vendor_hashes;

        return $this;
    }

    /**
     * Gets vendors
     *
     * @return \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneVendor[]|null
     */
    public function getVendors()
    {
        return $this->container['vendors'];
    }

    /**
     * Sets vendors
     *
     * @param \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneVendor[]|null $vendors Replaces vendorHashes, which I knew was going to be trouble the day it walked in the door. This will return not only what Vendors are active and relevant to the activity (in an implied order that you can choose to ignore), but also other data - for example, if the Vendor is featuring a specific item relevant to this event that you should show with them.
     *
     * @return self
     */
    public function setVendors($vendors)
    {
        $this->container['vendors'] = $vendors;

        return $this;
    }

    /**
     * Gets rewards
     *
     * @return \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneRewardCategory[]|null
     */
    public function getRewards()
    {
        return $this->container['rewards'];
    }

    /**
     * Sets rewards
     *
     * @param \OpenAPI\Client\Model\DestinyMilestonesDestinyMilestoneRewardCategory[]|null $rewards If the entity to which this component is attached has known active Rewards for the player, this will detail information about those rewards, keyed by the RewardEntry Hash. (See DestinyMilestoneDefinition for more information about Reward Entries) Note that these rewards are not for the Quests related to the Milestone. Think of these as \"overview/checklist\" rewards that may be provided for Milestones that may provide rewards for performing a variety of tasks that aren't under a specific Quest.
     *
     * @return self
     */
    public function setRewards($rewards)
    {
        $this->container['rewards'] = $rewards;

        return $this;
    }

    /**
     * Gets start_date
     *
     * @return \DateTime|null
     */
    public function getStartDate()
    {
        return $this->container['start_date'];
    }

    /**
     * Sets start_date
     *
     * @param \DateTime|null $start_date If known, this is the date when the event last began or refreshed. It will only be populated for events with fixed and repeating start and end dates.
     *
     * @return self
     */
    public function setStartDate($start_date)
    {
        $this->container['start_date'] = $start_date;

        return $this;
    }

    /**
     * Gets end_date
     *
     * @return \DateTime|null
     */
    public function getEndDate()
    {
        return $this->container['end_date'];
    }

    /**
     * Sets end_date
     *
     * @param \DateTime|null $end_date If known, this is the date when the event will next end or repeat. It will only be populated for events with fixed and repeating start and end dates.
     *
     * @return self
     */
    public function setEndDate($end_date)
    {
        $this->container['end_date'] = $end_date;

        return $this;
    }

    /**
     * Gets order
     *
     * @return int|null
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param int|null $order Used for ordering milestones in a display to match how we order them in BNet. May pull from static data, or possibly in the future from dynamic information.
     *
     * @return self
     */
    public function setOrder($order)
    {
        $this->container['order'] = $order;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


