<?php
/**
 * DestinyEntitiesItemsDestinyItemComponent
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyEntitiesItemsDestinyItemComponent Class Doc Comment
 *
 * @category Class
 * @description The base item component, filled with properties that are generally useful to know in any item request or that don&#39;t feel worthwhile to put in their own component.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyEntitiesItemsDestinyItemComponent implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Entities.Items.DestinyItemComponent';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'item_hash' => 'int',
        'item_instance_id' => 'int',
        'quantity' => 'int',
        'bind_status' => 'int',
        'location' => 'int',
        'bucket_hash' => 'int',
        'transfer_status' => 'int',
        'lockable' => 'bool',
        'state' => 'int',
        'override_style_item_hash' => 'int',
        'expiration_date' => '\DateTime',
        'is_wrapper' => 'bool',
        'tooltip_notification_indexes' => 'int[]',
        'metric_hash' => 'int',
        'metric_objective' => 'DestinyQuestsDestinyObjectiveProgress',
        'version_number' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'item_hash' => 'uint32',
        'item_instance_id' => 'int64',
        'quantity' => 'int32',
        'bind_status' => 'int32',
        'location' => 'int32',
        'bucket_hash' => 'uint32',
        'transfer_status' => 'int32',
        'lockable' => null,
        'state' => 'int32',
        'override_style_item_hash' => 'uint32',
        'expiration_date' => 'date-time',
        'is_wrapper' => null,
        'tooltip_notification_indexes' => 'int32',
        'metric_hash' => 'uint32',
        'metric_objective' => null,
        'version_number' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'item_hash' => 'itemHash',
        'item_instance_id' => 'itemInstanceId',
        'quantity' => 'quantity',
        'bind_status' => 'bindStatus',
        'location' => 'location',
        'bucket_hash' => 'bucketHash',
        'transfer_status' => 'transferStatus',
        'lockable' => 'lockable',
        'state' => 'state',
        'override_style_item_hash' => 'overrideStyleItemHash',
        'expiration_date' => 'expirationDate',
        'is_wrapper' => 'isWrapper',
        'tooltip_notification_indexes' => 'tooltipNotificationIndexes',
        'metric_hash' => 'metricHash',
        'metric_objective' => 'metricObjective',
        'version_number' => 'versionNumber'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'item_hash' => 'setItemHash',
        'item_instance_id' => 'setItemInstanceId',
        'quantity' => 'setQuantity',
        'bind_status' => 'setBindStatus',
        'location' => 'setLocation',
        'bucket_hash' => 'setBucketHash',
        'transfer_status' => 'setTransferStatus',
        'lockable' => 'setLockable',
        'state' => 'setState',
        'override_style_item_hash' => 'setOverrideStyleItemHash',
        'expiration_date' => 'setExpirationDate',
        'is_wrapper' => 'setIsWrapper',
        'tooltip_notification_indexes' => 'setTooltipNotificationIndexes',
        'metric_hash' => 'setMetricHash',
        'metric_objective' => 'setMetricObjective',
        'version_number' => 'setVersionNumber'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'item_hash' => 'getItemHash',
        'item_instance_id' => 'getItemInstanceId',
        'quantity' => 'getQuantity',
        'bind_status' => 'getBindStatus',
        'location' => 'getLocation',
        'bucket_hash' => 'getBucketHash',
        'transfer_status' => 'getTransferStatus',
        'lockable' => 'getLockable',
        'state' => 'getState',
        'override_style_item_hash' => 'getOverrideStyleItemHash',
        'expiration_date' => 'getExpirationDate',
        'is_wrapper' => 'getIsWrapper',
        'tooltip_notification_indexes' => 'getTooltipNotificationIndexes',
        'metric_hash' => 'getMetricHash',
        'metric_objective' => 'getMetricObjective',
        'version_number' => 'getVersionNumber'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['item_hash'] = $data['item_hash'] ?? null;
        $this->container['item_instance_id'] = $data['item_instance_id'] ?? null;
        $this->container['quantity'] = $data['quantity'] ?? null;
        $this->container['bind_status'] = $data['bind_status'] ?? null;
        $this->container['location'] = $data['location'] ?? null;
        $this->container['bucket_hash'] = $data['bucket_hash'] ?? null;
        $this->container['transfer_status'] = $data['transfer_status'] ?? null;
        $this->container['lockable'] = $data['lockable'] ?? null;
        $this->container['state'] = $data['state'] ?? null;
        $this->container['override_style_item_hash'] = $data['override_style_item_hash'] ?? null;
        $this->container['expiration_date'] = $data['expiration_date'] ?? null;
        $this->container['is_wrapper'] = $data['is_wrapper'] ?? null;
        $this->container['tooltip_notification_indexes'] = $data['tooltip_notification_indexes'] ?? null;
        $this->container['metric_hash'] = $data['metric_hash'] ?? null;
        $this->container['metric_objective'] = $data['metric_objective'] ?? null;
        $this->container['version_number'] = $data['version_number'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets item_hash
     *
     * @return int|null
     */
    public function getItemHash()
    {
        return $this->container['item_hash'];
    }

    /**
     * Sets item_hash
     *
     * @param int|null $item_hash The identifier for the item's definition, which is where most of the useful static information for the item can be found.
     *
     * @return self
     */
    public function setItemHash($item_hash)
    {
        $this->container['item_hash'] = $item_hash;

        return $this;
    }

    /**
     * Gets item_instance_id
     *
     * @return int|null
     */
    public function getItemInstanceId()
    {
        return $this->container['item_instance_id'];
    }

    /**
     * Sets item_instance_id
     *
     * @param int|null $item_instance_id If the item is instanced, it will have an instance ID. Lack of an instance ID implies that the item has no distinct local qualities aside from stack size.
     *
     * @return self
     */
    public function setItemInstanceId($item_instance_id)
    {
        $this->container['item_instance_id'] = $item_instance_id;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int|null
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int|null $quantity The quantity of the item in this stack. Note that Instanced items cannot stack. If an instanced item, this value will always be 1 (as the stack has exactly one item in it)
     *
     * @return self
     */
    public function setQuantity($quantity)
    {
        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets bind_status
     *
     * @return int|null
     */
    public function getBindStatus()
    {
        return $this->container['bind_status'];
    }

    /**
     * Sets bind_status
     *
     * @param int|null $bind_status If the item is bound to a location, it will be specified in this enum.
     *
     * @return self
     */
    public function setBindStatus($bind_status)
    {
        $this->container['bind_status'] = $bind_status;

        return $this;
    }

    /**
     * Gets location
     *
     * @return int|null
     */
    public function getLocation()
    {
        return $this->container['location'];
    }

    /**
     * Sets location
     *
     * @param int|null $location An easy reference for where the item is located. Redundant if you got the item from an Inventory, but useful when making detail calls on specific items.
     *
     * @return self
     */
    public function setLocation($location)
    {
        $this->container['location'] = $location;

        return $this;
    }

    /**
     * Gets bucket_hash
     *
     * @return int|null
     */
    public function getBucketHash()
    {
        return $this->container['bucket_hash'];
    }

    /**
     * Sets bucket_hash
     *
     * @param int|null $bucket_hash The hash identifier for the specific inventory bucket in which the item is located.
     *
     * @return self
     */
    public function setBucketHash($bucket_hash)
    {
        $this->container['bucket_hash'] = $bucket_hash;

        return $this;
    }

    /**
     * Gets transfer_status
     *
     * @return int|null
     */
    public function getTransferStatus()
    {
        return $this->container['transfer_status'];
    }

    /**
     * Sets transfer_status
     *
     * @param int|null $transfer_status If there is a known error state that would cause this item to not be transferable, this Flags enum will indicate all of those error states. Otherwise, it will be 0 (CanTransfer).
     *
     * @return self
     */
    public function setTransferStatus($transfer_status)
    {
        $this->container['transfer_status'] = $transfer_status;

        return $this;
    }

    /**
     * Gets lockable
     *
     * @return bool|null
     */
    public function getLockable()
    {
        return $this->container['lockable'];
    }

    /**
     * Sets lockable
     *
     * @param bool|null $lockable If the item can be locked, this will indicate that state.
     *
     * @return self
     */
    public function setLockable($lockable)
    {
        $this->container['lockable'] = $lockable;

        return $this;
    }

    /**
     * Gets state
     *
     * @return int|null
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param int|null $state A flags enumeration indicating the transient/custom states of the item that affect how it is rendered: whether it's tracked or locked for example, or whether it has a masterwork plug inserted.
     *
     * @return self
     */
    public function setState($state)
    {
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets override_style_item_hash
     *
     * @return int|null
     */
    public function getOverrideStyleItemHash()
    {
        return $this->container['override_style_item_hash'];
    }

    /**
     * Sets override_style_item_hash
     *
     * @param int|null $override_style_item_hash If populated, this is the hash of the item whose icon (and other secondary styles, but *not* the human readable strings) should override whatever icons/styles are on the item being sold.  If you don't do this, certain items whose styles are being overridden by socketed items - such as the \"Recycle Shader\" item - would show whatever their default icon/style is, and it wouldn't be pretty or look accurate.
     *
     * @return self
     */
    public function setOverrideStyleItemHash($override_style_item_hash)
    {
        $this->container['override_style_item_hash'] = $override_style_item_hash;

        return $this;
    }

    /**
     * Gets expiration_date
     *
     * @return \DateTime|null
     */
    public function getExpirationDate()
    {
        return $this->container['expiration_date'];
    }

    /**
     * Sets expiration_date
     *
     * @param \DateTime|null $expiration_date If the item can expire, this is the date at which it will/did expire.
     *
     * @return self
     */
    public function setExpirationDate($expiration_date)
    {
        $this->container['expiration_date'] = $expiration_date;

        return $this;
    }

    /**
     * Gets is_wrapper
     *
     * @return bool|null
     */
    public function getIsWrapper()
    {
        return $this->container['is_wrapper'];
    }

    /**
     * Sets is_wrapper
     *
     * @param bool|null $is_wrapper If this is true, the object is actually a \"wrapper\" of the object it's representing. This means that it's not the actual item itself, but rather an item that must be \"opened\" in game before you have and can use the item.   Wrappers are an evolution of \"bundles\", which give an easy way to let you preview the contents of what you purchased while still letting you get a refund before you \"open\" it.
     *
     * @return self
     */
    public function setIsWrapper($is_wrapper)
    {
        $this->container['is_wrapper'] = $is_wrapper;

        return $this;
    }

    /**
     * Gets tooltip_notification_indexes
     *
     * @return int[]|null
     */
    public function getTooltipNotificationIndexes()
    {
        return $this->container['tooltip_notification_indexes'];
    }

    /**
     * Sets tooltip_notification_indexes
     *
     * @param int[]|null $tooltip_notification_indexes If this is populated, it is a list of indexes into DestinyInventoryItemDefinition.tooltipNotifications for any special tooltip messages that need to be shown for this item.
     *
     * @return self
     */
    public function setTooltipNotificationIndexes($tooltip_notification_indexes)
    {
        $this->container['tooltip_notification_indexes'] = $tooltip_notification_indexes;

        return $this;
    }

    /**
     * Gets metric_hash
     *
     * @return int|null
     */
    public function getMetricHash()
    {
        return $this->container['metric_hash'];
    }

    /**
     * Sets metric_hash
     *
     * @param int|null $metric_hash The identifier for the currently-selected metric definition, to be displayed on the emblem nameplate.
     *
     * @return self
     */
    public function setMetricHash($metric_hash)
    {
        $this->container['metric_hash'] = $metric_hash;

        return $this;
    }

    /**
     * Gets metric_objective
     *
     * @return DestinyQuestsDestinyObjectiveProgress|null
     */
    public function getMetricObjective()
    {
        return $this->container['metric_objective'];
    }

    /**
     * Sets metric_objective
     *
     * @param DestinyQuestsDestinyObjectiveProgress|null $metric_objective The objective progress for the currently-selected metric definition, to be displayed on the emblem nameplate.
     *
     * @return self
     */
    public function setMetricObjective($metric_objective)
    {
        $this->container['metric_objective'] = $metric_objective;

        return $this;
    }

    /**
     * Gets version_number
     *
     * @return int|null
     */
    public function getVersionNumber()
    {
        return $this->container['version_number'];
    }

    /**
     * Sets version_number
     *
     * @param int|null $version_number The version of this item, used to index into the versions list in the item definition quality block.
     *
     * @return self
     */
    public function setVersionNumber($version_number)
    {
        $this->container['version_number'] = $version_number;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


