<?php
/**
 * DestinyDefinitionsDestinyVendorCategoryEntryDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyVendorCategoryEntryDefinition Class Doc Comment
 *
 * @category Class
 * @description This is the definition for a single Vendor Category, into which Sale Items are grouped.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyVendorCategoryEntryDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyVendorCategoryEntryDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'category_index' => 'int',
        'sort_value' => 'int',
        'category_hash' => 'int',
        'quantity_available' => 'int',
        'show_unavailable_items' => 'bool',
        'hide_if_no_currency' => 'bool',
        'hide_from_regular_purchase' => 'bool',
        'buy_string_override' => 'string',
        'disabled_description' => 'string',
        'display_title' => 'string',
        'overlay' => 'DestinyDefinitionsDestinyVendorCategoryOverlayDefinition',
        'vendor_item_indexes' => 'int[]',
        'is_preview' => 'bool',
        'is_display_only' => 'bool',
        'reset_interval_minutes_override' => 'int',
        'reset_offset_minutes_override' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'category_index' => 'int32',
        'sort_value' => 'int32',
        'category_hash' => 'uint32',
        'quantity_available' => 'int32',
        'show_unavailable_items' => null,
        'hide_if_no_currency' => null,
        'hide_from_regular_purchase' => null,
        'buy_string_override' => null,
        'disabled_description' => null,
        'display_title' => null,
        'overlay' => null,
        'vendor_item_indexes' => 'int32',
        'is_preview' => null,
        'is_display_only' => null,
        'reset_interval_minutes_override' => 'int32',
        'reset_offset_minutes_override' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'category_index' => 'categoryIndex',
        'sort_value' => 'sortValue',
        'category_hash' => 'categoryHash',
        'quantity_available' => 'quantityAvailable',
        'show_unavailable_items' => 'showUnavailableItems',
        'hide_if_no_currency' => 'hideIfNoCurrency',
        'hide_from_regular_purchase' => 'hideFromRegularPurchase',
        'buy_string_override' => 'buyStringOverride',
        'disabled_description' => 'disabledDescription',
        'display_title' => 'displayTitle',
        'overlay' => 'overlay',
        'vendor_item_indexes' => 'vendorItemIndexes',
        'is_preview' => 'isPreview',
        'is_display_only' => 'isDisplayOnly',
        'reset_interval_minutes_override' => 'resetIntervalMinutesOverride',
        'reset_offset_minutes_override' => 'resetOffsetMinutesOverride'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'category_index' => 'setCategoryIndex',
        'sort_value' => 'setSortValue',
        'category_hash' => 'setCategoryHash',
        'quantity_available' => 'setQuantityAvailable',
        'show_unavailable_items' => 'setShowUnavailableItems',
        'hide_if_no_currency' => 'setHideIfNoCurrency',
        'hide_from_regular_purchase' => 'setHideFromRegularPurchase',
        'buy_string_override' => 'setBuyStringOverride',
        'disabled_description' => 'setDisabledDescription',
        'display_title' => 'setDisplayTitle',
        'overlay' => 'setOverlay',
        'vendor_item_indexes' => 'setVendorItemIndexes',
        'is_preview' => 'setIsPreview',
        'is_display_only' => 'setIsDisplayOnly',
        'reset_interval_minutes_override' => 'setResetIntervalMinutesOverride',
        'reset_offset_minutes_override' => 'setResetOffsetMinutesOverride'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'category_index' => 'getCategoryIndex',
        'sort_value' => 'getSortValue',
        'category_hash' => 'getCategoryHash',
        'quantity_available' => 'getQuantityAvailable',
        'show_unavailable_items' => 'getShowUnavailableItems',
        'hide_if_no_currency' => 'getHideIfNoCurrency',
        'hide_from_regular_purchase' => 'getHideFromRegularPurchase',
        'buy_string_override' => 'getBuyStringOverride',
        'disabled_description' => 'getDisabledDescription',
        'display_title' => 'getDisplayTitle',
        'overlay' => 'getOverlay',
        'vendor_item_indexes' => 'getVendorItemIndexes',
        'is_preview' => 'getIsPreview',
        'is_display_only' => 'getIsDisplayOnly',
        'reset_interval_minutes_override' => 'getResetIntervalMinutesOverride',
        'reset_offset_minutes_override' => 'getResetOffsetMinutesOverride'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['category_index'] = $data['category_index'] ?? null;
        $this->container['sort_value'] = $data['sort_value'] ?? null;
        $this->container['category_hash'] = $data['category_hash'] ?? null;
        $this->container['quantity_available'] = $data['quantity_available'] ?? null;
        $this->container['show_unavailable_items'] = $data['show_unavailable_items'] ?? null;
        $this->container['hide_if_no_currency'] = $data['hide_if_no_currency'] ?? null;
        $this->container['hide_from_regular_purchase'] = $data['hide_from_regular_purchase'] ?? null;
        $this->container['buy_string_override'] = $data['buy_string_override'] ?? null;
        $this->container['disabled_description'] = $data['disabled_description'] ?? null;
        $this->container['display_title'] = $data['display_title'] ?? null;
        $this->container['overlay'] = $data['overlay'] ?? null;
        $this->container['vendor_item_indexes'] = $data['vendor_item_indexes'] ?? null;
        $this->container['is_preview'] = $data['is_preview'] ?? null;
        $this->container['is_display_only'] = $data['is_display_only'] ?? null;
        $this->container['reset_interval_minutes_override'] = $data['reset_interval_minutes_override'] ?? null;
        $this->container['reset_offset_minutes_override'] = $data['reset_offset_minutes_override'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets category_index
     *
     * @return int|null
     */
    public function getCategoryIndex()
    {
        return $this->container['category_index'];
    }

    /**
     * Sets category_index
     *
     * @param int|null $category_index The index of the category in the original category definitions for the vendor.
     *
     * @return self
     */
    public function setCategoryIndex($category_index)
    {
        $this->container['category_index'] = $category_index;

        return $this;
    }

    /**
     * Gets sort_value
     *
     * @return int|null
     */
    public function getSortValue()
    {
        return $this->container['sort_value'];
    }

    /**
     * Sets sort_value
     *
     * @param int|null $sort_value Used in sorting items in vendors... but there's a lot more to it. Just go with the order provided in the itemIndexes property on the DestinyVendorCategoryComponent instead, it should be more reliable than trying to recalculate it yourself.
     *
     * @return self
     */
    public function setSortValue($sort_value)
    {
        $this->container['sort_value'] = $sort_value;

        return $this;
    }

    /**
     * Gets category_hash
     *
     * @return int|null
     */
    public function getCategoryHash()
    {
        return $this->container['category_hash'];
    }

    /**
     * Sets category_hash
     *
     * @param int|null $category_hash The hashed identifier for the category.
     *
     * @return self
     */
    public function setCategoryHash($category_hash)
    {
        $this->container['category_hash'] = $category_hash;

        return $this;
    }

    /**
     * Gets quantity_available
     *
     * @return int|null
     */
    public function getQuantityAvailable()
    {
        return $this->container['quantity_available'];
    }

    /**
     * Sets quantity_available
     *
     * @param int|null $quantity_available The amount of items that will be available when this category is shown.
     *
     * @return self
     */
    public function setQuantityAvailable($quantity_available)
    {
        $this->container['quantity_available'] = $quantity_available;

        return $this;
    }

    /**
     * Gets show_unavailable_items
     *
     * @return bool|null
     */
    public function getShowUnavailableItems()
    {
        return $this->container['show_unavailable_items'];
    }

    /**
     * Sets show_unavailable_items
     *
     * @param bool|null $show_unavailable_items If items aren't up for sale in this category, should we still show them (greyed out)?
     *
     * @return self
     */
    public function setShowUnavailableItems($show_unavailable_items)
    {
        $this->container['show_unavailable_items'] = $show_unavailable_items;

        return $this;
    }

    /**
     * Gets hide_if_no_currency
     *
     * @return bool|null
     */
    public function getHideIfNoCurrency()
    {
        return $this->container['hide_if_no_currency'];
    }

    /**
     * Sets hide_if_no_currency
     *
     * @param bool|null $hide_if_no_currency If you don't have the currency required to buy items from this category, should the items be hidden?
     *
     * @return self
     */
    public function setHideIfNoCurrency($hide_if_no_currency)
    {
        $this->container['hide_if_no_currency'] = $hide_if_no_currency;

        return $this;
    }

    /**
     * Gets hide_from_regular_purchase
     *
     * @return bool|null
     */
    public function getHideFromRegularPurchase()
    {
        return $this->container['hide_from_regular_purchase'];
    }

    /**
     * Sets hide_from_regular_purchase
     *
     * @param bool|null $hide_from_regular_purchase True if this category doesn't allow purchases.
     *
     * @return self
     */
    public function setHideFromRegularPurchase($hide_from_regular_purchase)
    {
        $this->container['hide_from_regular_purchase'] = $hide_from_regular_purchase;

        return $this;
    }

    /**
     * Gets buy_string_override
     *
     * @return string|null
     */
    public function getBuyStringOverride()
    {
        return $this->container['buy_string_override'];
    }

    /**
     * Sets buy_string_override
     *
     * @param string|null $buy_string_override The localized string for making purchases from this category, if it is different from the vendor's string for purchasing.
     *
     * @return self
     */
    public function setBuyStringOverride($buy_string_override)
    {
        $this->container['buy_string_override'] = $buy_string_override;

        return $this;
    }

    /**
     * Gets disabled_description
     *
     * @return string|null
     */
    public function getDisabledDescription()
    {
        return $this->container['disabled_description'];
    }

    /**
     * Sets disabled_description
     *
     * @param string|null $disabled_description If the category is disabled, this is the localized description to show.
     *
     * @return self
     */
    public function setDisabledDescription($disabled_description)
    {
        $this->container['disabled_description'] = $disabled_description;

        return $this;
    }

    /**
     * Gets display_title
     *
     * @return string|null
     */
    public function getDisplayTitle()
    {
        return $this->container['display_title'];
    }

    /**
     * Sets display_title
     *
     * @param string|null $display_title The localized title of the category.
     *
     * @return self
     */
    public function setDisplayTitle($display_title)
    {
        $this->container['display_title'] = $display_title;

        return $this;
    }

    /**
     * Gets overlay
     *
     * @return DestinyDefinitionsDestinyVendorCategoryOverlayDefinition|null
     */
    public function getOverlay()
    {
        return $this->container['overlay'];
    }

    /**
     * Sets overlay
     *
     * @param DestinyDefinitionsDestinyVendorCategoryOverlayDefinition|null $overlay If this category has an overlay prompt that should appear, this contains the details of that prompt.
     *
     * @return self
     */
    public function setOverlay($overlay)
    {
        $this->container['overlay'] = $overlay;

        return $this;
    }

    /**
     * Gets vendor_item_indexes
     *
     * @return int[]|null
     */
    public function getVendorItemIndexes()
    {
        return $this->container['vendor_item_indexes'];
    }

    /**
     * Sets vendor_item_indexes
     *
     * @param int[]|null $vendor_item_indexes A shortcut for the vendor item indexes sold under this category. Saves us from some expensive reorganization at runtime.
     *
     * @return self
     */
    public function setVendorItemIndexes($vendor_item_indexes)
    {
        $this->container['vendor_item_indexes'] = $vendor_item_indexes;

        return $this;
    }

    /**
     * Gets is_preview
     *
     * @return bool|null
     */
    public function getIsPreview()
    {
        return $this->container['is_preview'];
    }

    /**
     * Sets is_preview
     *
     * @param bool|null $is_preview Sometimes a category isn't actually used to sell items, but rather to preview them. This implies different UI (and manual placement of the category in the UI) in the game, and special treatment.
     *
     * @return self
     */
    public function setIsPreview($is_preview)
    {
        $this->container['is_preview'] = $is_preview;

        return $this;
    }

    /**
     * Gets is_display_only
     *
     * @return bool|null
     */
    public function getIsDisplayOnly()
    {
        return $this->container['is_display_only'];
    }

    /**
     * Sets is_display_only
     *
     * @param bool|null $is_display_only If true, this category only displays items: you can't purchase anything in them.
     *
     * @return self
     */
    public function setIsDisplayOnly($is_display_only)
    {
        $this->container['is_display_only'] = $is_display_only;

        return $this;
    }

    /**
     * Gets reset_interval_minutes_override
     *
     * @return int|null
     */
    public function getResetIntervalMinutesOverride()
    {
        return $this->container['reset_interval_minutes_override'];
    }

    /**
     * Sets reset_interval_minutes_override
     *
     * @param int|null $reset_interval_minutes_override reset_interval_minutes_override
     *
     * @return self
     */
    public function setResetIntervalMinutesOverride($reset_interval_minutes_override)
    {
        $this->container['reset_interval_minutes_override'] = $reset_interval_minutes_override;

        return $this;
    }

    /**
     * Gets reset_offset_minutes_override
     *
     * @return int|null
     */
    public function getResetOffsetMinutesOverride()
    {
        return $this->container['reset_offset_minutes_override'];
    }

    /**
     * Sets reset_offset_minutes_override
     *
     * @param int|null $reset_offset_minutes_override reset_offset_minutes_override
     *
     * @return self
     */
    public function setResetOffsetMinutesOverride($reset_offset_minutes_override)
    {
        $this->container['reset_offset_minutes_override'] = $reset_offset_minutes_override;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


