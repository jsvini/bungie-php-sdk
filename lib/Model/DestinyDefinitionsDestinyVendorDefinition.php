<?php
/**
 * DestinyDefinitionsDestinyVendorDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyVendorDefinition Class Doc Comment
 *
 * @category Class
 * @description These are the definitions for Vendors.  In Destiny, a Vendor can be a lot of things - some things that you wouldn&#39;t expect, and some things that you don&#39;t even see directly in the game. Vendors are the Dolly Levi of the Destiny universe.  - Traditional Vendors as you see in game: people who you come up to and who give you quests, rewards, or who you can buy things from.  - Kiosks/Collections, which are really just Vendors that don&#39;t charge currency (or charge some pittance of a currency) and whose gating for purchases revolves more around your character&#39;s state.  - Previews for rewards or the contents of sacks. These are implemented as Vendors, where you can&#39;t actually purchase from them but the items that they have for sale and the categories of sale items reflect the rewards or contents of the sack. This is so that the game could reuse the existing Vendor display UI for rewards and save a bunch of wheel reinvention.  - Item Transfer capabilities, like the Vault and Postmaster. Vendors can have \&quot;acceptedItem\&quot; buckets that determine the source and destination buckets for transfers. When you interact with such a vendor, these buckets are what gets shown in the UI instead of any items that the Vendor would have for sale. Yep, the Vault is a vendor.  It is pretty much guaranteed that they&#39;ll be used for even more features in the future. They have come to be seen more as generic categorized containers for items than \&quot;vendors\&quot; in a traditional sense, for better or worse.  Where possible and time allows, we&#39;ll attempt to split those out into their own more digestible derived \&quot;Definitions\&quot;: but often time does not allow that, as you can see from the above ways that vendors are used which we never split off from Vendor Definitions externally.  Since Vendors are so many things to so many parts of the game, the definition is understandably complex. You will want to combine this data with live Vendor information from the API when it is available.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyVendorDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyVendorDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'display_properties' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorDisplayPropertiesDefinition',
        'buy_string' => 'string',
        'sell_string' => 'string',
        'display_item_hash' => 'int',
        'inhibit_buying' => 'bool',
        'inhibit_selling' => 'bool',
        'faction_hash' => 'int',
        'reset_interval_minutes' => 'int',
        'reset_offset_minutes' => 'int',
        'failure_strings' => 'string[]',
        'unlock_ranges' => '\OpenAPI\Client\Model\DatesDateRange[]',
        'vendor_identifier' => 'string',
        'vendor_portrait' => 'string',
        'vendor_banner' => 'string',
        'enabled' => 'bool',
        'visible' => 'bool',
        'vendor_subcategory_identifier' => 'string',
        'consolidate_categories' => 'bool',
        'actions' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorActionDefinition[]',
        'categories' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorCategoryEntryDefinition[]',
        'original_categories' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorCategoryEntryDefinition[]',
        'display_categories' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyDisplayCategoryDefinition[]',
        'interactions' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorInteractionDefinition[]',
        'inventory_flyouts' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorInventoryFlyoutDefinition[]',
        'item_list' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorItemDefinition[]',
        'services' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorServiceDefinition[]',
        'accepted_items' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorAcceptedItemDefinition[]',
        'return_with_vendor_request' => 'bool',
        'locations' => '\OpenAPI\Client\Model\DestinyDefinitionsVendorsDestinyVendorLocationDefinition[]',
        'groups' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorGroupReference[]',
        'ignore_sale_item_hashes' => 'int[]',
        'hash' => 'int',
        'index' => 'int',
        'redacted' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'display_properties' => null,
        'buy_string' => null,
        'sell_string' => null,
        'display_item_hash' => 'uint32',
        'inhibit_buying' => null,
        'inhibit_selling' => null,
        'faction_hash' => 'uint32',
        'reset_interval_minutes' => 'int32',
        'reset_offset_minutes' => 'int32',
        'failure_strings' => null,
        'unlock_ranges' => null,
        'vendor_identifier' => null,
        'vendor_portrait' => null,
        'vendor_banner' => null,
        'enabled' => null,
        'visible' => null,
        'vendor_subcategory_identifier' => null,
        'consolidate_categories' => null,
        'actions' => null,
        'categories' => null,
        'original_categories' => null,
        'display_categories' => null,
        'interactions' => null,
        'inventory_flyouts' => null,
        'item_list' => null,
        'services' => null,
        'accepted_items' => null,
        'return_with_vendor_request' => null,
        'locations' => null,
        'groups' => null,
        'ignore_sale_item_hashes' => 'uint32',
        'hash' => 'uint32',
        'index' => 'int32',
        'redacted' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'display_properties' => 'displayProperties',
        'buy_string' => 'buyString',
        'sell_string' => 'sellString',
        'display_item_hash' => 'displayItemHash',
        'inhibit_buying' => 'inhibitBuying',
        'inhibit_selling' => 'inhibitSelling',
        'faction_hash' => 'factionHash',
        'reset_interval_minutes' => 'resetIntervalMinutes',
        'reset_offset_minutes' => 'resetOffsetMinutes',
        'failure_strings' => 'failureStrings',
        'unlock_ranges' => 'unlockRanges',
        'vendor_identifier' => 'vendorIdentifier',
        'vendor_portrait' => 'vendorPortrait',
        'vendor_banner' => 'vendorBanner',
        'enabled' => 'enabled',
        'visible' => 'visible',
        'vendor_subcategory_identifier' => 'vendorSubcategoryIdentifier',
        'consolidate_categories' => 'consolidateCategories',
        'actions' => 'actions',
        'categories' => 'categories',
        'original_categories' => 'originalCategories',
        'display_categories' => 'displayCategories',
        'interactions' => 'interactions',
        'inventory_flyouts' => 'inventoryFlyouts',
        'item_list' => 'itemList',
        'services' => 'services',
        'accepted_items' => 'acceptedItems',
        'return_with_vendor_request' => 'returnWithVendorRequest',
        'locations' => 'locations',
        'groups' => 'groups',
        'ignore_sale_item_hashes' => 'ignoreSaleItemHashes',
        'hash' => 'hash',
        'index' => 'index',
        'redacted' => 'redacted'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'display_properties' => 'setDisplayProperties',
        'buy_string' => 'setBuyString',
        'sell_string' => 'setSellString',
        'display_item_hash' => 'setDisplayItemHash',
        'inhibit_buying' => 'setInhibitBuying',
        'inhibit_selling' => 'setInhibitSelling',
        'faction_hash' => 'setFactionHash',
        'reset_interval_minutes' => 'setResetIntervalMinutes',
        'reset_offset_minutes' => 'setResetOffsetMinutes',
        'failure_strings' => 'setFailureStrings',
        'unlock_ranges' => 'setUnlockRanges',
        'vendor_identifier' => 'setVendorIdentifier',
        'vendor_portrait' => 'setVendorPortrait',
        'vendor_banner' => 'setVendorBanner',
        'enabled' => 'setEnabled',
        'visible' => 'setVisible',
        'vendor_subcategory_identifier' => 'setVendorSubcategoryIdentifier',
        'consolidate_categories' => 'setConsolidateCategories',
        'actions' => 'setActions',
        'categories' => 'setCategories',
        'original_categories' => 'setOriginalCategories',
        'display_categories' => 'setDisplayCategories',
        'interactions' => 'setInteractions',
        'inventory_flyouts' => 'setInventoryFlyouts',
        'item_list' => 'setItemList',
        'services' => 'setServices',
        'accepted_items' => 'setAcceptedItems',
        'return_with_vendor_request' => 'setReturnWithVendorRequest',
        'locations' => 'setLocations',
        'groups' => 'setGroups',
        'ignore_sale_item_hashes' => 'setIgnoreSaleItemHashes',
        'hash' => 'setHash',
        'index' => 'setIndex',
        'redacted' => 'setRedacted'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'display_properties' => 'getDisplayProperties',
        'buy_string' => 'getBuyString',
        'sell_string' => 'getSellString',
        'display_item_hash' => 'getDisplayItemHash',
        'inhibit_buying' => 'getInhibitBuying',
        'inhibit_selling' => 'getInhibitSelling',
        'faction_hash' => 'getFactionHash',
        'reset_interval_minutes' => 'getResetIntervalMinutes',
        'reset_offset_minutes' => 'getResetOffsetMinutes',
        'failure_strings' => 'getFailureStrings',
        'unlock_ranges' => 'getUnlockRanges',
        'vendor_identifier' => 'getVendorIdentifier',
        'vendor_portrait' => 'getVendorPortrait',
        'vendor_banner' => 'getVendorBanner',
        'enabled' => 'getEnabled',
        'visible' => 'getVisible',
        'vendor_subcategory_identifier' => 'getVendorSubcategoryIdentifier',
        'consolidate_categories' => 'getConsolidateCategories',
        'actions' => 'getActions',
        'categories' => 'getCategories',
        'original_categories' => 'getOriginalCategories',
        'display_categories' => 'getDisplayCategories',
        'interactions' => 'getInteractions',
        'inventory_flyouts' => 'getInventoryFlyouts',
        'item_list' => 'getItemList',
        'services' => 'getServices',
        'accepted_items' => 'getAcceptedItems',
        'return_with_vendor_request' => 'getReturnWithVendorRequest',
        'locations' => 'getLocations',
        'groups' => 'getGroups',
        'ignore_sale_item_hashes' => 'getIgnoreSaleItemHashes',
        'hash' => 'getHash',
        'index' => 'getIndex',
        'redacted' => 'getRedacted'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['display_properties'] = $data['display_properties'] ?? null;
        $this->container['buy_string'] = $data['buy_string'] ?? null;
        $this->container['sell_string'] = $data['sell_string'] ?? null;
        $this->container['display_item_hash'] = $data['display_item_hash'] ?? null;
        $this->container['inhibit_buying'] = $data['inhibit_buying'] ?? null;
        $this->container['inhibit_selling'] = $data['inhibit_selling'] ?? null;
        $this->container['faction_hash'] = $data['faction_hash'] ?? null;
        $this->container['reset_interval_minutes'] = $data['reset_interval_minutes'] ?? null;
        $this->container['reset_offset_minutes'] = $data['reset_offset_minutes'] ?? null;
        $this->container['failure_strings'] = $data['failure_strings'] ?? null;
        $this->container['unlock_ranges'] = $data['unlock_ranges'] ?? null;
        $this->container['vendor_identifier'] = $data['vendor_identifier'] ?? null;
        $this->container['vendor_portrait'] = $data['vendor_portrait'] ?? null;
        $this->container['vendor_banner'] = $data['vendor_banner'] ?? null;
        $this->container['enabled'] = $data['enabled'] ?? null;
        $this->container['visible'] = $data['visible'] ?? null;
        $this->container['vendor_subcategory_identifier'] = $data['vendor_subcategory_identifier'] ?? null;
        $this->container['consolidate_categories'] = $data['consolidate_categories'] ?? null;
        $this->container['actions'] = $data['actions'] ?? null;
        $this->container['categories'] = $data['categories'] ?? null;
        $this->container['original_categories'] = $data['original_categories'] ?? null;
        $this->container['display_categories'] = $data['display_categories'] ?? null;
        $this->container['interactions'] = $data['interactions'] ?? null;
        $this->container['inventory_flyouts'] = $data['inventory_flyouts'] ?? null;
        $this->container['item_list'] = $data['item_list'] ?? null;
        $this->container['services'] = $data['services'] ?? null;
        $this->container['accepted_items'] = $data['accepted_items'] ?? null;
        $this->container['return_with_vendor_request'] = $data['return_with_vendor_request'] ?? null;
        $this->container['locations'] = $data['locations'] ?? null;
        $this->container['groups'] = $data['groups'] ?? null;
        $this->container['ignore_sale_item_hashes'] = $data['ignore_sale_item_hashes'] ?? null;
        $this->container['hash'] = $data['hash'] ?? null;
        $this->container['index'] = $data['index'] ?? null;
        $this->container['redacted'] = $data['redacted'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets display_properties
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorDisplayPropertiesDefinition|null
     */
    public function getDisplayProperties()
    {
        return $this->container['display_properties'];
    }

    /**
     * Sets display_properties
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorDisplayPropertiesDefinition|null $display_properties display_properties
     *
     * @return self
     */
    public function setDisplayProperties($display_properties)
    {
        $this->container['display_properties'] = $display_properties;

        return $this;
    }

    /**
     * Gets buy_string
     *
     * @return string|null
     */
    public function getBuyString()
    {
        return $this->container['buy_string'];
    }

    /**
     * Sets buy_string
     *
     * @param string|null $buy_string If the vendor has a custom localized string describing the \"buy\" action, that is returned here.
     *
     * @return self
     */
    public function setBuyString($buy_string)
    {
        $this->container['buy_string'] = $buy_string;

        return $this;
    }

    /**
     * Gets sell_string
     *
     * @return string|null
     */
    public function getSellString()
    {
        return $this->container['sell_string'];
    }

    /**
     * Sets sell_string
     *
     * @param string|null $sell_string Ditto for selling. Not that you can sell items to a vendor anymore. Will it come back? Who knows. The string's still there.
     *
     * @return self
     */
    public function setSellString($sell_string)
    {
        $this->container['sell_string'] = $sell_string;

        return $this;
    }

    /**
     * Gets display_item_hash
     *
     * @return int|null
     */
    public function getDisplayItemHash()
    {
        return $this->container['display_item_hash'];
    }

    /**
     * Sets display_item_hash
     *
     * @param int|null $display_item_hash If the vendor has an item that should be displayed as the \"featured\" item, this is the hash identifier for that DestinyVendorItemDefinition.  Apparently this is usually a related currency, like a reputation token. But it need not be restricted to that.
     *
     * @return self
     */
    public function setDisplayItemHash($display_item_hash)
    {
        $this->container['display_item_hash'] = $display_item_hash;

        return $this;
    }

    /**
     * Gets inhibit_buying
     *
     * @return bool|null
     */
    public function getInhibitBuying()
    {
        return $this->container['inhibit_buying'];
    }

    /**
     * Sets inhibit_buying
     *
     * @param bool|null $inhibit_buying If this is true, you aren't allowed to buy whatever the vendor is selling.
     *
     * @return self
     */
    public function setInhibitBuying($inhibit_buying)
    {
        $this->container['inhibit_buying'] = $inhibit_buying;

        return $this;
    }

    /**
     * Gets inhibit_selling
     *
     * @return bool|null
     */
    public function getInhibitSelling()
    {
        return $this->container['inhibit_selling'];
    }

    /**
     * Sets inhibit_selling
     *
     * @param bool|null $inhibit_selling If this is true, you're not allowed to sell whatever the vendor is buying.
     *
     * @return self
     */
    public function setInhibitSelling($inhibit_selling)
    {
        $this->container['inhibit_selling'] = $inhibit_selling;

        return $this;
    }

    /**
     * Gets faction_hash
     *
     * @return int|null
     */
    public function getFactionHash()
    {
        return $this->container['faction_hash'];
    }

    /**
     * Sets faction_hash
     *
     * @param int|null $faction_hash If the Vendor has a faction, this hash will be valid and point to a DestinyFactionDefinition.  The game UI and BNet often mine the faction definition for additional elements and details to place on the screen, such as the faction's Progression status (aka \"Reputation\").
     *
     * @return self
     */
    public function setFactionHash($faction_hash)
    {
        $this->container['faction_hash'] = $faction_hash;

        return $this;
    }

    /**
     * Gets reset_interval_minutes
     *
     * @return int|null
     */
    public function getResetIntervalMinutes()
    {
        return $this->container['reset_interval_minutes'];
    }

    /**
     * Sets reset_interval_minutes
     *
     * @param int|null $reset_interval_minutes A number used for calculating the frequency of a vendor's inventory resetting/refreshing.  Don't worry about calculating this - we do it on the server side and send you the next refresh date with the live data.
     *
     * @return self
     */
    public function setResetIntervalMinutes($reset_interval_minutes)
    {
        $this->container['reset_interval_minutes'] = $reset_interval_minutes;

        return $this;
    }

    /**
     * Gets reset_offset_minutes
     *
     * @return int|null
     */
    public function getResetOffsetMinutes()
    {
        return $this->container['reset_offset_minutes'];
    }

    /**
     * Sets reset_offset_minutes
     *
     * @param int|null $reset_offset_minutes Again, used for reset/refreshing of inventory. Don't worry too much about it. Unless you want to.
     *
     * @return self
     */
    public function setResetOffsetMinutes($reset_offset_minutes)
    {
        $this->container['reset_offset_minutes'] = $reset_offset_minutes;

        return $this;
    }

    /**
     * Gets failure_strings
     *
     * @return string[]|null
     */
    public function getFailureStrings()
    {
        return $this->container['failure_strings'];
    }

    /**
     * Sets failure_strings
     *
     * @param string[]|null $failure_strings If an item can't be purchased from the vendor, there may be many \"custom\"/game state specific reasons why not.  This is a list of localized strings with messages for those custom failures. The live BNet data will return a failureIndexes property for items that can't be purchased: using those values to index into this array, you can show the user the appropriate failure message for the item that can't be bought.
     *
     * @return self
     */
    public function setFailureStrings($failure_strings)
    {
        $this->container['failure_strings'] = $failure_strings;

        return $this;
    }

    /**
     * Gets unlock_ranges
     *
     * @return \OpenAPI\Client\Model\DatesDateRange[]|null
     */
    public function getUnlockRanges()
    {
        return $this->container['unlock_ranges'];
    }

    /**
     * Sets unlock_ranges
     *
     * @param \OpenAPI\Client\Model\DatesDateRange[]|null $unlock_ranges If we were able to predict the dates when this Vendor will be visible/available, this will be the list of those date ranges. Sadly, we're not able to predict this very frequently, so this will often be useless data.
     *
     * @return self
     */
    public function setUnlockRanges($unlock_ranges)
    {
        $this->container['unlock_ranges'] = $unlock_ranges;

        return $this;
    }

    /**
     * Gets vendor_identifier
     *
     * @return string|null
     */
    public function getVendorIdentifier()
    {
        return $this->container['vendor_identifier'];
    }

    /**
     * Sets vendor_identifier
     *
     * @param string|null $vendor_identifier The internal identifier for the Vendor. A holdover from the old days of Vendors, but we don't have time to refactor it away.
     *
     * @return self
     */
    public function setVendorIdentifier($vendor_identifier)
    {
        $this->container['vendor_identifier'] = $vendor_identifier;

        return $this;
    }

    /**
     * Gets vendor_portrait
     *
     * @return string|null
     */
    public function getVendorPortrait()
    {
        return $this->container['vendor_portrait'];
    }

    /**
     * Sets vendor_portrait
     *
     * @param string|null $vendor_portrait A portrait of the Vendor's smiling mug. Or frothing tentacles.
     *
     * @return self
     */
    public function setVendorPortrait($vendor_portrait)
    {
        $this->container['vendor_portrait'] = $vendor_portrait;

        return $this;
    }

    /**
     * Gets vendor_banner
     *
     * @return string|null
     */
    public function getVendorBanner()
    {
        return $this->container['vendor_banner'];
    }

    /**
     * Sets vendor_banner
     *
     * @param string|null $vendor_banner If the vendor has a custom banner image, that can be found here.
     *
     * @return self
     */
    public function setVendorBanner($vendor_banner)
    {
        $this->container['vendor_banner'] = $vendor_banner;

        return $this;
    }

    /**
     * Gets enabled
     *
     * @return bool|null
     */
    public function getEnabled()
    {
        return $this->container['enabled'];
    }

    /**
     * Sets enabled
     *
     * @param bool|null $enabled If a vendor is not enabled, we won't even save the vendor's definition, and we won't return any items or info about them. It's as if they don't exist.
     *
     * @return self
     */
    public function setEnabled($enabled)
    {
        $this->container['enabled'] = $enabled;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible If a vendor is not visible, we still have and will give vendor definition info, but we won't use them for things like Advisors or UI.
     *
     * @return self
     */
    public function setVisible($visible)
    {
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets vendor_subcategory_identifier
     *
     * @return string|null
     */
    public function getVendorSubcategoryIdentifier()
    {
        return $this->container['vendor_subcategory_identifier'];
    }

    /**
     * Sets vendor_subcategory_identifier
     *
     * @param string|null $vendor_subcategory_identifier The identifier of the VendorCategoryDefinition for this vendor's subcategory.
     *
     * @return self
     */
    public function setVendorSubcategoryIdentifier($vendor_subcategory_identifier)
    {
        $this->container['vendor_subcategory_identifier'] = $vendor_subcategory_identifier;

        return $this;
    }

    /**
     * Gets consolidate_categories
     *
     * @return bool|null
     */
    public function getConsolidateCategories()
    {
        return $this->container['consolidate_categories'];
    }

    /**
     * Sets consolidate_categories
     *
     * @param bool|null $consolidate_categories If TRUE, consolidate categories that only differ by trivial properties (such as having minor differences in name)
     *
     * @return self
     */
    public function setConsolidateCategories($consolidate_categories)
    {
        $this->container['consolidate_categories'] = $consolidate_categories;

        return $this;
    }

    /**
     * Gets actions
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorActionDefinition[]|null
     */
    public function getActions()
    {
        return $this->container['actions'];
    }

    /**
     * Sets actions
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorActionDefinition[]|null $actions Describes \"actions\" that can be performed on a vendor. Currently, none of these exist. But theoretically a Vendor could let you interact with it by performing actions. We'll see what these end up looking like if they ever get used.
     *
     * @return self
     */
    public function setActions($actions)
    {
        $this->container['actions'] = $actions;

        return $this;
    }

    /**
     * Gets categories
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorCategoryEntryDefinition[]|null
     */
    public function getCategories()
    {
        return $this->container['categories'];
    }

    /**
     * Sets categories
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorCategoryEntryDefinition[]|null $categories These are the headers for sections of items that the vendor is selling. When you see items organized by category in the header, it is these categories that it is showing.  Well, technically not *exactly* these. On BNet, it doesn't make sense to have categories be \"paged\" as we do in Destiny, so we run some heuristics to attempt to aggregate pages of categories together.   These are the categories post-concatenation, if the vendor had concatenation applied. If you want the pre-aggregated category data, use originalCategories.
     *
     * @return self
     */
    public function setCategories($categories)
    {
        $this->container['categories'] = $categories;

        return $this;
    }

    /**
     * Gets original_categories
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorCategoryEntryDefinition[]|null
     */
    public function getOriginalCategories()
    {
        return $this->container['original_categories'];
    }

    /**
     * Sets original_categories
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorCategoryEntryDefinition[]|null $original_categories See the categories property for a description of categories and why originalCategories exists.
     *
     * @return self
     */
    public function setOriginalCategories($original_categories)
    {
        $this->container['original_categories'] = $original_categories;

        return $this;
    }

    /**
     * Gets display_categories
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyDisplayCategoryDefinition[]|null
     */
    public function getDisplayCategories()
    {
        return $this->container['display_categories'];
    }

    /**
     * Sets display_categories
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyDisplayCategoryDefinition[]|null $display_categories Display Categories are different from \"categories\" in that these are specifically for visual grouping and display of categories in Vendor UI.   The \"categories\" structure is for validation of the contained items, and can be categorized entirely separately from \"Display Categories\", there need be and often will be no meaningful relationship between the two.
     *
     * @return self
     */
    public function setDisplayCategories($display_categories)
    {
        $this->container['display_categories'] = $display_categories;

        return $this;
    }

    /**
     * Gets interactions
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorInteractionDefinition[]|null
     */
    public function getInteractions()
    {
        return $this->container['interactions'];
    }

    /**
     * Sets interactions
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorInteractionDefinition[]|null $interactions In addition to selling items, vendors can have \"interactions\": UI where you \"talk\" with the vendor and they offer you a reward, some item, or merely acknowledge via dialog that you did something cool.
     *
     * @return self
     */
    public function setInteractions($interactions)
    {
        $this->container['interactions'] = $interactions;

        return $this;
    }

    /**
     * Gets inventory_flyouts
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorInventoryFlyoutDefinition[]|null
     */
    public function getInventoryFlyouts()
    {
        return $this->container['inventory_flyouts'];
    }

    /**
     * Sets inventory_flyouts
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorInventoryFlyoutDefinition[]|null $inventory_flyouts If the vendor shows you items from your own inventory - such as the Vault vendor does - this data describes the UI around showing those inventory buckets and which ones get shown.
     *
     * @return self
     */
    public function setInventoryFlyouts($inventory_flyouts)
    {
        $this->container['inventory_flyouts'] = $inventory_flyouts;

        return $this;
    }

    /**
     * Gets item_list
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorItemDefinition[]|null
     */
    public function getItemList()
    {
        return $this->container['item_list'];
    }

    /**
     * Sets item_list
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorItemDefinition[]|null $item_list If the vendor sells items (or merely has a list of items to show like the \"Sack\" vendors do), this is the list of those items that the vendor can sell. From this list, only a subset will be available from the vendor at any given time, selected randomly and reset on the vendor's refresh interval.  Note that a vendor can sell the same item multiple ways: for instance, nothing stops a vendor from selling you some specific weapon but using two different currencies, or the same weapon at multiple \"item levels\".
     *
     * @return self
     */
    public function setItemList($item_list)
    {
        $this->container['item_list'] = $item_list;

        return $this;
    }

    /**
     * Gets services
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorServiceDefinition[]|null
     */
    public function getServices()
    {
        return $this->container['services'];
    }

    /**
     * Sets services
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorServiceDefinition[]|null $services BNet doesn't use this data yet, but it appears to be an optional list of flavor text about services that the Vendor can provide.
     *
     * @return self
     */
    public function setServices($services)
    {
        $this->container['services'] = $services;

        return $this;
    }

    /**
     * Gets accepted_items
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorAcceptedItemDefinition[]|null
     */
    public function getAcceptedItems()
    {
        return $this->container['accepted_items'];
    }

    /**
     * Sets accepted_items
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorAcceptedItemDefinition[]|null $accepted_items If the Vendor is actually a vehicle for the transferring of items (like the Vault and Postmaster vendors), this defines the list of source->destination buckets for transferring.
     *
     * @return self
     */
    public function setAcceptedItems($accepted_items)
    {
        $this->container['accepted_items'] = $accepted_items;

        return $this;
    }

    /**
     * Gets return_with_vendor_request
     *
     * @return bool|null
     */
    public function getReturnWithVendorRequest()
    {
        return $this->container['return_with_vendor_request'];
    }

    /**
     * Sets return_with_vendor_request
     *
     * @param bool|null $return_with_vendor_request As many of you know, Vendor data has historically been pretty brutal on the BNet servers. In an effort to reduce this workload, only Vendors with this flag set will be returned on Vendor requests. This allows us to filter out Vendors that don't dynamic data that's particularly useful: things like \"Preview/Sack\" vendors, for example, that you can usually suss out the details for using just the definitions themselves.
     *
     * @return self
     */
    public function setReturnWithVendorRequest($return_with_vendor_request)
    {
        $this->container['return_with_vendor_request'] = $return_with_vendor_request;

        return $this;
    }

    /**
     * Gets locations
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsVendorsDestinyVendorLocationDefinition[]|null
     */
    public function getLocations()
    {
        return $this->container['locations'];
    }

    /**
     * Sets locations
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsVendorsDestinyVendorLocationDefinition[]|null $locations A vendor can be at different places in the world depending on the game/character/account state. This is the list of possible locations for the vendor, along with conditions we use to determine which one is currently active.
     *
     * @return self
     */
    public function setLocations($locations)
    {
        $this->container['locations'] = $locations;

        return $this;
    }

    /**
     * Gets groups
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorGroupReference[]|null
     */
    public function getGroups()
    {
        return $this->container['groups'];
    }

    /**
     * Sets groups
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyVendorGroupReference[]|null $groups A vendor can be a part of 0 or 1 \"groups\" at a time: a group being a collection of Vendors related by either location or function/purpose. It's used for our our Companion Vendor UI. Only one of these can be active for a Vendor at a time.
     *
     * @return self
     */
    public function setGroups($groups)
    {
        $this->container['groups'] = $groups;

        return $this;
    }

    /**
     * Gets ignore_sale_item_hashes
     *
     * @return int[]|null
     */
    public function getIgnoreSaleItemHashes()
    {
        return $this->container['ignore_sale_item_hashes'];
    }

    /**
     * Sets ignore_sale_item_hashes
     *
     * @param int[]|null $ignore_sale_item_hashes Some items don't make sense to return in the API, for example because they represent an action to be performed rather than an item being sold. I'd rather we not do this, but at least in the short term this is a workable workaround.
     *
     * @return self
     */
    public function setIgnoreSaleItemHashes($ignore_sale_item_hashes)
    {
        $this->container['ignore_sale_item_hashes'] = $ignore_sale_item_hashes;

        return $this;
    }

    /**
     * Gets hash
     *
     * @return int|null
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param int|null $hash The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
     *
     * @return self
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets index
     *
     * @return int|null
     */
    public function getIndex()
    {
        return $this->container['index'];
    }

    /**
     * Sets index
     *
     * @param int|null $index The index of the entity as it was found in the investment tables.
     *
     * @return self
     */
    public function setIndex($index)
    {
        $this->container['index'] = $index;

        return $this;
    }

    /**
     * Gets redacted
     *
     * @return bool|null
     */
    public function getRedacted()
    {
        return $this->container['redacted'];
    }

    /**
     * Sets redacted
     *
     * @param bool|null $redacted If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
     *
     * @return self
     */
    public function setRedacted($redacted)
    {
        $this->container['redacted'] = $redacted;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


