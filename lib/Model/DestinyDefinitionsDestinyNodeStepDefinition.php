<?php
/**
 * DestinyDefinitionsDestinyNodeStepDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyNodeStepDefinition Class Doc Comment
 *
 * @category Class
 * @description This defines the properties of a \&quot;Talent Node Step\&quot;. When you see a talent node in game, the actual visible properties that you see (its icon, description, the perks and stats it provides) are not provided by the Node itself, but rather by the currently active Step on the node.  When a Talent Node is activated, the currently active step&#39;s benefits are conferred upon the item and character.  The currently active step on talent nodes are determined when an item is first instantiated. Sometimes it is random, sometimes it is more deterministic (particularly when a node has only a single step).  Note that, when dealing with Talent Node Steps, you must ensure that you have the latest version of content. stepIndex and nodeStepHash - two ways of identifying the step within a node - are both content version dependent, and thus are subject to change between content updates.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyNodeStepDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyNodeStepDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'display_properties' => 'DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition',
        'step_index' => 'int',
        'node_step_hash' => 'int',
        'interaction_description' => 'string',
        'damage_type' => 'int',
        'damage_type_hash' => 'int',
        'activation_requirement' => 'DestinyDefinitionsDestinyNodeActivationRequirement',
        'can_activate_next_step' => 'bool',
        'next_step_index' => 'int',
        'is_next_step_random' => 'bool',
        'perk_hashes' => 'int[]',
        'start_progression_bar_at_progress' => 'int',
        'stat_hashes' => 'int[]',
        'affects_quality' => 'bool',
        'step_groups' => 'DestinyDefinitionsDestinyTalentNodeStepGroups',
        'affects_level' => 'bool',
        'socket_replacements' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyNodeSocketReplaceResponse[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'display_properties' => null,
        'step_index' => 'int32',
        'node_step_hash' => 'uint32',
        'interaction_description' => null,
        'damage_type' => 'int32',
        'damage_type_hash' => 'uint32',
        'activation_requirement' => null,
        'can_activate_next_step' => null,
        'next_step_index' => 'int32',
        'is_next_step_random' => null,
        'perk_hashes' => 'uint32',
        'start_progression_bar_at_progress' => 'int32',
        'stat_hashes' => 'uint32',
        'affects_quality' => null,
        'step_groups' => null,
        'affects_level' => null,
        'socket_replacements' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'display_properties' => 'displayProperties',
        'step_index' => 'stepIndex',
        'node_step_hash' => 'nodeStepHash',
        'interaction_description' => 'interactionDescription',
        'damage_type' => 'damageType',
        'damage_type_hash' => 'damageTypeHash',
        'activation_requirement' => 'activationRequirement',
        'can_activate_next_step' => 'canActivateNextStep',
        'next_step_index' => 'nextStepIndex',
        'is_next_step_random' => 'isNextStepRandom',
        'perk_hashes' => 'perkHashes',
        'start_progression_bar_at_progress' => 'startProgressionBarAtProgress',
        'stat_hashes' => 'statHashes',
        'affects_quality' => 'affectsQuality',
        'step_groups' => 'stepGroups',
        'affects_level' => 'affectsLevel',
        'socket_replacements' => 'socketReplacements'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'display_properties' => 'setDisplayProperties',
        'step_index' => 'setStepIndex',
        'node_step_hash' => 'setNodeStepHash',
        'interaction_description' => 'setInteractionDescription',
        'damage_type' => 'setDamageType',
        'damage_type_hash' => 'setDamageTypeHash',
        'activation_requirement' => 'setActivationRequirement',
        'can_activate_next_step' => 'setCanActivateNextStep',
        'next_step_index' => 'setNextStepIndex',
        'is_next_step_random' => 'setIsNextStepRandom',
        'perk_hashes' => 'setPerkHashes',
        'start_progression_bar_at_progress' => 'setStartProgressionBarAtProgress',
        'stat_hashes' => 'setStatHashes',
        'affects_quality' => 'setAffectsQuality',
        'step_groups' => 'setStepGroups',
        'affects_level' => 'setAffectsLevel',
        'socket_replacements' => 'setSocketReplacements'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'display_properties' => 'getDisplayProperties',
        'step_index' => 'getStepIndex',
        'node_step_hash' => 'getNodeStepHash',
        'interaction_description' => 'getInteractionDescription',
        'damage_type' => 'getDamageType',
        'damage_type_hash' => 'getDamageTypeHash',
        'activation_requirement' => 'getActivationRequirement',
        'can_activate_next_step' => 'getCanActivateNextStep',
        'next_step_index' => 'getNextStepIndex',
        'is_next_step_random' => 'getIsNextStepRandom',
        'perk_hashes' => 'getPerkHashes',
        'start_progression_bar_at_progress' => 'getStartProgressionBarAtProgress',
        'stat_hashes' => 'getStatHashes',
        'affects_quality' => 'getAffectsQuality',
        'step_groups' => 'getStepGroups',
        'affects_level' => 'getAffectsLevel',
        'socket_replacements' => 'getSocketReplacements'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['display_properties'] = $data['display_properties'] ?? null;
        $this->container['step_index'] = $data['step_index'] ?? null;
        $this->container['node_step_hash'] = $data['node_step_hash'] ?? null;
        $this->container['interaction_description'] = $data['interaction_description'] ?? null;
        $this->container['damage_type'] = $data['damage_type'] ?? null;
        $this->container['damage_type_hash'] = $data['damage_type_hash'] ?? null;
        $this->container['activation_requirement'] = $data['activation_requirement'] ?? null;
        $this->container['can_activate_next_step'] = $data['can_activate_next_step'] ?? null;
        $this->container['next_step_index'] = $data['next_step_index'] ?? null;
        $this->container['is_next_step_random'] = $data['is_next_step_random'] ?? null;
        $this->container['perk_hashes'] = $data['perk_hashes'] ?? null;
        $this->container['start_progression_bar_at_progress'] = $data['start_progression_bar_at_progress'] ?? null;
        $this->container['stat_hashes'] = $data['stat_hashes'] ?? null;
        $this->container['affects_quality'] = $data['affects_quality'] ?? null;
        $this->container['step_groups'] = $data['step_groups'] ?? null;
        $this->container['affects_level'] = $data['affects_level'] ?? null;
        $this->container['socket_replacements'] = $data['socket_replacements'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets display_properties
     *
     * @return DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null
     */
    public function getDisplayProperties()
    {
        return $this->container['display_properties'];
    }

    /**
     * Sets display_properties
     *
     * @param DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null $display_properties These are the display properties actually used to render the Talent Node. The currently active step's displayProperties are shown.
     *
     * @return self
     */
    public function setDisplayProperties($display_properties)
    {
        $this->container['display_properties'] = $display_properties;

        return $this;
    }

    /**
     * Gets step_index
     *
     * @return int|null
     */
    public function getStepIndex()
    {
        return $this->container['step_index'];
    }

    /**
     * Sets step_index
     *
     * @param int|null $step_index The index of this step in the list of Steps on the Talent Node.  Unfortunately, this is the closest thing we have to an identifier for the Step: steps are not provided a content version agnostic identifier. This means that, when you are dealing with talent nodes, you will need to first ensure that you have the latest version of content.
     *
     * @return self
     */
    public function setStepIndex($step_index)
    {
        $this->container['step_index'] = $step_index;

        return $this;
    }

    /**
     * Gets node_step_hash
     *
     * @return int|null
     */
    public function getNodeStepHash()
    {
        return $this->container['node_step_hash'];
    }

    /**
     * Sets node_step_hash
     *
     * @param int|null $node_step_hash The hash of this node step. Unfortunately, while it can be used to uniquely identify the step within a node, it is also content version dependent and should not be relied on without ensuring you have the latest vesion of content.
     *
     * @return self
     */
    public function setNodeStepHash($node_step_hash)
    {
        $this->container['node_step_hash'] = $node_step_hash;

        return $this;
    }

    /**
     * Gets interaction_description
     *
     * @return string|null
     */
    public function getInteractionDescription()
    {
        return $this->container['interaction_description'];
    }

    /**
     * Sets interaction_description
     *
     * @param string|null $interaction_description If you can interact with this node in some way, this is the localized description of that interaction.
     *
     * @return self
     */
    public function setInteractionDescription($interaction_description)
    {
        $this->container['interaction_description'] = $interaction_description;

        return $this;
    }

    /**
     * Gets damage_type
     *
     * @return int|null
     */
    public function getDamageType()
    {
        return $this->container['damage_type'];
    }

    /**
     * Sets damage_type
     *
     * @param int|null $damage_type An enum representing a damage type granted by activating this step, if any.
     *
     * @return self
     */
    public function setDamageType($damage_type)
    {
        $this->container['damage_type'] = $damage_type;

        return $this;
    }

    /**
     * Gets damage_type_hash
     *
     * @return int|null
     */
    public function getDamageTypeHash()
    {
        return $this->container['damage_type_hash'];
    }

    /**
     * Sets damage_type_hash
     *
     * @param int|null $damage_type_hash If the step provides a damage type, this will be the hash identifier used to look up the damage type's DestinyDamageTypeDefinition.
     *
     * @return self
     */
    public function setDamageTypeHash($damage_type_hash)
    {
        $this->container['damage_type_hash'] = $damage_type_hash;

        return $this;
    }

    /**
     * Gets activation_requirement
     *
     * @return DestinyDefinitionsDestinyNodeActivationRequirement|null
     */
    public function getActivationRequirement()
    {
        return $this->container['activation_requirement'];
    }

    /**
     * Sets activation_requirement
     *
     * @param DestinyDefinitionsDestinyNodeActivationRequirement|null $activation_requirement If the step has requirements for activation (they almost always do, if nothing else than for the Talent Grid's Progression to have reached a certain level), they will be defined here.
     *
     * @return self
     */
    public function setActivationRequirement($activation_requirement)
    {
        $this->container['activation_requirement'] = $activation_requirement;

        return $this;
    }

    /**
     * Gets can_activate_next_step
     *
     * @return bool|null
     */
    public function getCanActivateNextStep()
    {
        return $this->container['can_activate_next_step'];
    }

    /**
     * Sets can_activate_next_step
     *
     * @param bool|null $can_activate_next_step There was a time when talent nodes could be activated multiple times, and the effects of subsequent Steps would be compounded on each other, essentially \"upgrading\" the node. We have moved away from this, but theoretically the capability still exists.  I continue to return this in case it is used in the future: if true and this step is the current step in the node, you are allowed to activate the node a second time to receive the benefits of the next step in the node, which will then become the active step.
     *
     * @return self
     */
    public function setCanActivateNextStep($can_activate_next_step)
    {
        $this->container['can_activate_next_step'] = $can_activate_next_step;

        return $this;
    }

    /**
     * Gets next_step_index
     *
     * @return int|null
     */
    public function getNextStepIndex()
    {
        return $this->container['next_step_index'];
    }

    /**
     * Sets next_step_index
     *
     * @param int|null $next_step_index The stepIndex of the next step in the talent node, or -1 if this is the last step or if the next step to be chosen is random.  This doesn't really matter anymore unless canActivateNextStep begins to be used again.
     *
     * @return self
     */
    public function setNextStepIndex($next_step_index)
    {
        $this->container['next_step_index'] = $next_step_index;

        return $this;
    }

    /**
     * Gets is_next_step_random
     *
     * @return bool|null
     */
    public function getIsNextStepRandom()
    {
        return $this->container['is_next_step_random'];
    }

    /**
     * Sets is_next_step_random
     *
     * @param bool|null $is_next_step_random If true, the next step to be chosen is random, and if you're allowed to activate the next step. (if canActivateNextStep = true)
     *
     * @return self
     */
    public function setIsNextStepRandom($is_next_step_random)
    {
        $this->container['is_next_step_random'] = $is_next_step_random;

        return $this;
    }

    /**
     * Gets perk_hashes
     *
     * @return int[]|null
     */
    public function getPerkHashes()
    {
        return $this->container['perk_hashes'];
    }

    /**
     * Sets perk_hashes
     *
     * @param int[]|null $perk_hashes The list of hash identifiers for Perks (DestinySandboxPerkDefinition) that are applied when this step is active. Perks provide a variety of benefits and modifications - examine DestinySandboxPerkDefinition to learn more.
     *
     * @return self
     */
    public function setPerkHashes($perk_hashes)
    {
        $this->container['perk_hashes'] = $perk_hashes;

        return $this;
    }

    /**
     * Gets start_progression_bar_at_progress
     *
     * @return int|null
     */
    public function getStartProgressionBarAtProgress()
    {
        return $this->container['start_progression_bar_at_progress'];
    }

    /**
     * Sets start_progression_bar_at_progress
     *
     * @param int|null $start_progression_bar_at_progress When the Talent Grid's progression reaches this value, the circular \"progress bar\" that surrounds the talent node should be shown.  This also indicates the lower bound of said progress bar, with the upper bound being the progress required to reach activationRequirement.gridLevel. (at some point I should precalculate the upper bound and put it in the definition to save people time)
     *
     * @return self
     */
    public function setStartProgressionBarAtProgress($start_progression_bar_at_progress)
    {
        $this->container['start_progression_bar_at_progress'] = $start_progression_bar_at_progress;

        return $this;
    }

    /**
     * Gets stat_hashes
     *
     * @return int[]|null
     */
    public function getStatHashes()
    {
        return $this->container['stat_hashes'];
    }

    /**
     * Sets stat_hashes
     *
     * @param int[]|null $stat_hashes When the step provides stat benefits on the item or character, this is the list of hash identifiers for stats (DestinyStatDefinition) that are provided.
     *
     * @return self
     */
    public function setStatHashes($stat_hashes)
    {
        $this->container['stat_hashes'] = $stat_hashes;

        return $this;
    }

    /**
     * Gets affects_quality
     *
     * @return bool|null
     */
    public function getAffectsQuality()
    {
        return $this->container['affects_quality'];
    }

    /**
     * Sets affects_quality
     *
     * @param bool|null $affects_quality If this is true, the step affects the item's Quality in some way. See DestinyInventoryItemDefinition for more information about the meaning of Quality. I already made a joke about Zen and the Art of Motorcycle Maintenance elsewhere in the documentation, so I will avoid doing it again. Oops too late
     *
     * @return self
     */
    public function setAffectsQuality($affects_quality)
    {
        $this->container['affects_quality'] = $affects_quality;

        return $this;
    }

    /**
     * Gets step_groups
     *
     * @return DestinyDefinitionsDestinyTalentNodeStepGroups|null
     */
    public function getStepGroups()
    {
        return $this->container['step_groups'];
    }

    /**
     * Sets step_groups
     *
     * @param DestinyDefinitionsDestinyTalentNodeStepGroups|null $step_groups In Destiny 1, the Armory's Perk Filtering was driven by a concept of TalentNodeStepGroups: categorizations of talent nodes based on their functionality. While the Armory isn't a BNet-facing thing for now, and the new Armory will need to account for Sockets rather than Talent Nodes, this categorization capability feels useful enough to still keep around.
     *
     * @return self
     */
    public function setStepGroups($step_groups)
    {
        $this->container['step_groups'] = $step_groups;

        return $this;
    }

    /**
     * Gets affects_level
     *
     * @return bool|null
     */
    public function getAffectsLevel()
    {
        return $this->container['affects_level'];
    }

    /**
     * Sets affects_level
     *
     * @param bool|null $affects_level If true, this step can affect the level of the item. See DestinyInventoryItemDefintion for more information about item levels and their effect on stats.
     *
     * @return self
     */
    public function setAffectsLevel($affects_level)
    {
        $this->container['affects_level'] = $affects_level;

        return $this;
    }

    /**
     * Gets socket_replacements
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyNodeSocketReplaceResponse[]|null
     */
    public function getSocketReplacements()
    {
        return $this->container['socket_replacements'];
    }

    /**
     * Sets socket_replacements
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyNodeSocketReplaceResponse[]|null $socket_replacements If this step is activated, this will be a list of information used to replace socket items with new Plugs. See DestinyInventoryItemDefinition for more information about sockets and plugs.
     *
     * @return self
     */
    public function setSocketReplacements($socket_replacements)
    {
        $this->container['socket_replacements'] = $socket_replacements;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


