<?php
/**
 * DestinyDefinitionsDestinyItemStatBlockDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyItemStatBlockDefinition Class Doc Comment
 *
 * @category Class
 * @description Information about the item&#39;s calculated stats, with as much data as we can find for the stats without having an actual instance of the item.  Note that this means the entire concept of providing these stats is fundamentally insufficient: we cannot predict with 100% accuracy the conditions under which an item can spawn, so we use various heuristics to attempt to simulate the conditions as accurately as possible. Actual stats for items in-game can and will vary, but these should at least be useful base points for comparison and display.  It is also worth noting that some stats, like Magazine size, have further calculations performed on them by scripts in-game and on the game servers that BNet does not have access to. We cannot know how those stats are further transformed, and thus some stats will be inaccurate even on instances of items in BNet vs. how they appear in-game. This is a known limitation of our item statistics, without any planned fix.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyItemStatBlockDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyItemStatBlockDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'disable_primary_stat_display' => 'bool',
        'stat_group_hash' => 'int',
        'stats' => 'map[string,\OpenAPI\Client\Model\DestinyDefinitionsDestinyInventoryItemStatDefinition]',
        'has_displayable_stats' => 'bool',
        'primary_base_stat_hash' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'disable_primary_stat_display' => null,
        'stat_group_hash' => 'uint32',
        'stats' => null,
        'has_displayable_stats' => null,
        'primary_base_stat_hash' => 'uint32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'disable_primary_stat_display' => 'disablePrimaryStatDisplay',
        'stat_group_hash' => 'statGroupHash',
        'stats' => 'stats',
        'has_displayable_stats' => 'hasDisplayableStats',
        'primary_base_stat_hash' => 'primaryBaseStatHash'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'disable_primary_stat_display' => 'setDisablePrimaryStatDisplay',
        'stat_group_hash' => 'setStatGroupHash',
        'stats' => 'setStats',
        'has_displayable_stats' => 'setHasDisplayableStats',
        'primary_base_stat_hash' => 'setPrimaryBaseStatHash'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'disable_primary_stat_display' => 'getDisablePrimaryStatDisplay',
        'stat_group_hash' => 'getStatGroupHash',
        'stats' => 'getStats',
        'has_displayable_stats' => 'getHasDisplayableStats',
        'primary_base_stat_hash' => 'getPrimaryBaseStatHash'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['disable_primary_stat_display'] = $data['disable_primary_stat_display'] ?? null;
        $this->container['stat_group_hash'] = $data['stat_group_hash'] ?? null;
        $this->container['stats'] = $data['stats'] ?? null;
        $this->container['has_displayable_stats'] = $data['has_displayable_stats'] ?? null;
        $this->container['primary_base_stat_hash'] = $data['primary_base_stat_hash'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets disable_primary_stat_display
     *
     * @return bool|null
     */
    public function getDisablePrimaryStatDisplay()
    {
        return $this->container['disable_primary_stat_display'];
    }

    /**
     * Sets disable_primary_stat_display
     *
     * @param bool|null $disable_primary_stat_display If true, the game won't show the \"primary\" stat on this item when you inspect it.  NOTE: This is being manually mapped, because I happen to want it in a block that isn't going to directly create this derivative block.
     *
     * @return self
     */
    public function setDisablePrimaryStatDisplay($disable_primary_stat_display)
    {
        $this->container['disable_primary_stat_display'] = $disable_primary_stat_display;

        return $this;
    }

    /**
     * Gets stat_group_hash
     *
     * @return int|null
     */
    public function getStatGroupHash()
    {
        return $this->container['stat_group_hash'];
    }

    /**
     * Sets stat_group_hash
     *
     * @param int|null $stat_group_hash If the item's stats are meant to be modified by a DestinyStatGroupDefinition, this will be the identifier for that definition.  If you are using live data or precomputed stats data on the DestinyInventoryItemDefinition.stats.stats property, you don't have to worry about statGroupHash and how it alters stats: the already altered stats are provided to you. But if you want to see how the sausage gets made, or perform computations yourself, this is valuable information.
     *
     * @return self
     */
    public function setStatGroupHash($stat_group_hash)
    {
        $this->container['stat_group_hash'] = $stat_group_hash;

        return $this;
    }

    /**
     * Gets stats
     *
     * @return map[string,\OpenAPI\Client\Model\DestinyDefinitionsDestinyInventoryItemStatDefinition]|null
     */
    public function getStats()
    {
        return $this->container['stats'];
    }

    /**
     * Sets stats
     *
     * @param map[string,\OpenAPI\Client\Model\DestinyDefinitionsDestinyInventoryItemStatDefinition]|null $stats If you are looking for precomputed values for the stats on a weapon, this is where they are stored. Technically these are the \"Display\" stat values. Please see DestinyStatsDefinition for what Display Stat Values means, it's a very long story... but essentially these are the closest values BNet can get to the item stats that you see in-game.  These stats are keyed by the DestinyStatDefinition's hash identifier for the stat that's found on the item.
     *
     * @return self
     */
    public function setStats($stats)
    {
        $this->container['stats'] = $stats;

        return $this;
    }

    /**
     * Gets has_displayable_stats
     *
     * @return bool|null
     */
    public function getHasDisplayableStats()
    {
        return $this->container['has_displayable_stats'];
    }

    /**
     * Sets has_displayable_stats
     *
     * @param bool|null $has_displayable_stats A quick and lazy way to determine whether any stat other than the \"primary\" stat is actually visible on the item. Items often have stats that we return in case people find them useful, but they're not part of the \"Stat Group\" and thus we wouldn't display them in our UI. If this is False, then we're not going to display any of these stats other than the primary one.
     *
     * @return self
     */
    public function setHasDisplayableStats($has_displayable_stats)
    {
        $this->container['has_displayable_stats'] = $has_displayable_stats;

        return $this;
    }

    /**
     * Gets primary_base_stat_hash
     *
     * @return int|null
     */
    public function getPrimaryBaseStatHash()
    {
        return $this->container['primary_base_stat_hash'];
    }

    /**
     * Sets primary_base_stat_hash
     *
     * @param int|null $primary_base_stat_hash This stat is determined to be the \"primary\" stat, and can be looked up in the stats or any other stat collection related to the item.  Use this hash to look up the stat's value using DestinyInventoryItemDefinition.stats.stats, and the renderable data for the primary stat in the related DestinyStatDefinition.
     *
     * @return self
     */
    public function setPrimaryBaseStatHash($primary_base_stat_hash)
    {
        $this->container['primary_base_stat_hash'] = $primary_base_stat_hash;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


