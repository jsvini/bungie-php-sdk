<?php
/**
 * DestinyDefinitionsDestinyActivityModeDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyActivityModeDefinition Class Doc Comment
 *
 * @category Class
 * @description This definition represents an \&quot;Activity Mode\&quot; as it exists in the Historical Stats endpoints. An individual Activity Mode represents a collection of activities that are played in a certain way. For example, Nightfall Strikes are part of a \&quot;Nightfall\&quot; activity mode, and any activities played as the PVP mode \&quot;Clash\&quot; are part of the \&quot;Clash activity mode.  Activity modes are nested under each other in a hierarchy, so that if you ask for - for example - \&quot;AllPvP\&quot;, you will get any PVP activities that the user has played, regardless of what specific PVP mode was being played.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyActivityModeDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyActivityModeDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'display_properties' => '\OpenAPI\Client\Model\DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition',
        'pgcr_image' => 'string',
        'mode_type' => 'int',
        'activity_mode_category' => 'int',
        'is_team_based' => 'bool',
        'is_aggregate_mode' => 'bool',
        'parent_hashes' => 'int[]',
        'friendly_name' => 'string',
        'activity_mode_mappings' => 'map[string,int]',
        'display' => 'bool',
        'order' => 'int',
        'hash' => 'int',
        'index' => 'int',
        'redacted' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'display_properties' => null,
        'pgcr_image' => null,
        'mode_type' => 'int32',
        'activity_mode_category' => 'int32',
        'is_team_based' => null,
        'is_aggregate_mode' => null,
        'parent_hashes' => 'uint32',
        'friendly_name' => null,
        'activity_mode_mappings' => 'int32',
        'display' => null,
        'order' => 'int32',
        'hash' => 'uint32',
        'index' => 'int32',
        'redacted' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'display_properties' => 'displayProperties',
        'pgcr_image' => 'pgcrImage',
        'mode_type' => 'modeType',
        'activity_mode_category' => 'activityModeCategory',
        'is_team_based' => 'isTeamBased',
        'is_aggregate_mode' => 'isAggregateMode',
        'parent_hashes' => 'parentHashes',
        'friendly_name' => 'friendlyName',
        'activity_mode_mappings' => 'activityModeMappings',
        'display' => 'display',
        'order' => 'order',
        'hash' => 'hash',
        'index' => 'index',
        'redacted' => 'redacted'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'display_properties' => 'setDisplayProperties',
        'pgcr_image' => 'setPgcrImage',
        'mode_type' => 'setModeType',
        'activity_mode_category' => 'setActivityModeCategory',
        'is_team_based' => 'setIsTeamBased',
        'is_aggregate_mode' => 'setIsAggregateMode',
        'parent_hashes' => 'setParentHashes',
        'friendly_name' => 'setFriendlyName',
        'activity_mode_mappings' => 'setActivityModeMappings',
        'display' => 'setDisplay',
        'order' => 'setOrder',
        'hash' => 'setHash',
        'index' => 'setIndex',
        'redacted' => 'setRedacted'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'display_properties' => 'getDisplayProperties',
        'pgcr_image' => 'getPgcrImage',
        'mode_type' => 'getModeType',
        'activity_mode_category' => 'getActivityModeCategory',
        'is_team_based' => 'getIsTeamBased',
        'is_aggregate_mode' => 'getIsAggregateMode',
        'parent_hashes' => 'getParentHashes',
        'friendly_name' => 'getFriendlyName',
        'activity_mode_mappings' => 'getActivityModeMappings',
        'display' => 'getDisplay',
        'order' => 'getOrder',
        'hash' => 'getHash',
        'index' => 'getIndex',
        'redacted' => 'getRedacted'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['display_properties'] = $data['display_properties'] ?? null;
        $this->container['pgcr_image'] = $data['pgcr_image'] ?? null;
        $this->container['mode_type'] = $data['mode_type'] ?? null;
        $this->container['activity_mode_category'] = $data['activity_mode_category'] ?? null;
        $this->container['is_team_based'] = $data['is_team_based'] ?? null;
        $this->container['is_aggregate_mode'] = $data['is_aggregate_mode'] ?? null;
        $this->container['parent_hashes'] = $data['parent_hashes'] ?? null;
        $this->container['friendly_name'] = $data['friendly_name'] ?? null;
        $this->container['activity_mode_mappings'] = $data['activity_mode_mappings'] ?? null;
        $this->container['display'] = $data['display'] ?? null;
        $this->container['order'] = $data['order'] ?? null;
        $this->container['hash'] = $data['hash'] ?? null;
        $this->container['index'] = $data['index'] ?? null;
        $this->container['redacted'] = $data['redacted'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets display_properties
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null
     */
    public function getDisplayProperties()
    {
        return $this->container['display_properties'];
    }

    /**
     * Sets display_properties
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null $display_properties display_properties
     *
     * @return self
     */
    public function setDisplayProperties($display_properties)
    {
        $this->container['display_properties'] = $display_properties;

        return $this;
    }

    /**
     * Gets pgcr_image
     *
     * @return string|null
     */
    public function getPgcrImage()
    {
        return $this->container['pgcr_image'];
    }

    /**
     * Sets pgcr_image
     *
     * @param string|null $pgcr_image If this activity mode has a related PGCR image, this will be the path to said image.
     *
     * @return self
     */
    public function setPgcrImage($pgcr_image)
    {
        $this->container['pgcr_image'] = $pgcr_image;

        return $this;
    }

    /**
     * Gets mode_type
     *
     * @return int|null
     */
    public function getModeType()
    {
        return $this->container['mode_type'];
    }

    /**
     * Sets mode_type
     *
     * @param int|null $mode_type The Enumeration value for this Activity Mode. Pass this identifier into Stats endpoints to get aggregate stats for this mode.
     *
     * @return self
     */
    public function setModeType($mode_type)
    {
        $this->container['mode_type'] = $mode_type;

        return $this;
    }

    /**
     * Gets activity_mode_category
     *
     * @return int|null
     */
    public function getActivityModeCategory()
    {
        return $this->container['activity_mode_category'];
    }

    /**
     * Sets activity_mode_category
     *
     * @param int|null $activity_mode_category The type of play being performed in broad terms (PVP, PVE)
     *
     * @return self
     */
    public function setActivityModeCategory($activity_mode_category)
    {
        $this->container['activity_mode_category'] = $activity_mode_category;

        return $this;
    }

    /**
     * Gets is_team_based
     *
     * @return bool|null
     */
    public function getIsTeamBased()
    {
        return $this->container['is_team_based'];
    }

    /**
     * Sets is_team_based
     *
     * @param bool|null $is_team_based If True, this mode has oppositional teams fighting against each other rather than \"Free-For-All\" or Co-operative modes of play.  Note that Aggregate modes are never marked as team based, even if they happen to be team based at the moment. At any time, an aggregate whose subordinates are only team based could be changed so that one or more aren't team based, and then this boolean won't make much sense (the aggregation would become \"sometimes team based\"). Let's not deal with that right now.
     *
     * @return self
     */
    public function setIsTeamBased($is_team_based)
    {
        $this->container['is_team_based'] = $is_team_based;

        return $this;
    }

    /**
     * Gets is_aggregate_mode
     *
     * @return bool|null
     */
    public function getIsAggregateMode()
    {
        return $this->container['is_aggregate_mode'];
    }

    /**
     * Sets is_aggregate_mode
     *
     * @param bool|null $is_aggregate_mode If true, this mode is an aggregation of other, more specific modes rather than being a mode in itself. This includes modes that group Features/Events rather than Gameplay, such as Trials of The Nine: Trials of the Nine being an Event that is interesting to see aggregate data for, but when you play the activities within Trials of the Nine they are more specific activity modes such as Clash.
     *
     * @return self
     */
    public function setIsAggregateMode($is_aggregate_mode)
    {
        $this->container['is_aggregate_mode'] = $is_aggregate_mode;

        return $this;
    }

    /**
     * Gets parent_hashes
     *
     * @return int[]|null
     */
    public function getParentHashes()
    {
        return $this->container['parent_hashes'];
    }

    /**
     * Sets parent_hashes
     *
     * @param int[]|null $parent_hashes The hash identifiers of the DestinyActivityModeDefinitions that represent all of the \"parent\" modes for this mode. For instance, the Nightfall Mode is also a member of AllStrikes and AllPvE.
     *
     * @return self
     */
    public function setParentHashes($parent_hashes)
    {
        $this->container['parent_hashes'] = $parent_hashes;

        return $this;
    }

    /**
     * Gets friendly_name
     *
     * @return string|null
     */
    public function getFriendlyName()
    {
        return $this->container['friendly_name'];
    }

    /**
     * Sets friendly_name
     *
     * @param string|null $friendly_name A Friendly identifier you can use for referring to this Activity Mode. We really only used this in our URLs, so... you know, take that for whatever it's worth.
     *
     * @return self
     */
    public function setFriendlyName($friendly_name)
    {
        $this->container['friendly_name'] = $friendly_name;

        return $this;
    }

    /**
     * Gets activity_mode_mappings
     *
     * @return map[string,int]|null
     */
    public function getActivityModeMappings()
    {
        return $this->container['activity_mode_mappings'];
    }

    /**
     * Sets activity_mode_mappings
     *
     * @param map[string,int]|null $activity_mode_mappings If this exists, the mode has specific Activities (referred to by the Key) that should instead map to other Activity Modes when they are played. This was useful in D1 for Private Matches, where we wanted to have Private Matches as an activity mode while still referring to the specific mode being played.
     *
     * @return self
     */
    public function setActivityModeMappings($activity_mode_mappings)
    {
        $this->container['activity_mode_mappings'] = $activity_mode_mappings;

        return $this;
    }

    /**
     * Gets display
     *
     * @return bool|null
     */
    public function getDisplay()
    {
        return $this->container['display'];
    }

    /**
     * Sets display
     *
     * @param bool|null $display If FALSE, we want to ignore this type when we're showing activity modes in BNet UI. It will still be returned in case 3rd parties want to use it for any purpose.
     *
     * @return self
     */
    public function setDisplay($display)
    {
        $this->container['display'] = $display;

        return $this;
    }

    /**
     * Gets order
     *
     * @return int|null
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param int|null $order The relative ordering of activity modes.
     *
     * @return self
     */
    public function setOrder($order)
    {
        $this->container['order'] = $order;

        return $this;
    }

    /**
     * Gets hash
     *
     * @return int|null
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param int|null $hash The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
     *
     * @return self
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets index
     *
     * @return int|null
     */
    public function getIndex()
    {
        return $this->container['index'];
    }

    /**
     * Sets index
     *
     * @param int|null $index The index of the entity as it was found in the investment tables.
     *
     * @return self
     */
    public function setIndex($index)
    {
        $this->container['index'] = $index;

        return $this;
    }

    /**
     * Gets redacted
     *
     * @return bool|null
     */
    public function getRedacted()
    {
        return $this->container['redacted'];
    }

    /**
     * Sets redacted
     *
     * @param bool|null $redacted If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
     *
     * @return self
     */
    public function setRedacted($redacted)
    {
        $this->container['redacted'] = $redacted;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


