<?php
/**
 * DestinyDefinitionsDestinyActivityDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyActivityDefinition Class Doc Comment
 *
 * @category Class
 * @description The static data about Activities in Destiny 2.  Note that an Activity must be combined with an ActivityMode to know - from a Gameplay perspective - what the user is \&quot;Playing\&quot;.  In most PvE activities, this is fairly straightforward. A Story Activity can only be played in the Story Activity Mode.  However, in PvP activities, the Activity alone only tells you the map being played, or the Playlist that the user chose to enter. You&#39;ll need to know the Activity Mode they&#39;re playing to know that they&#39;re playing Mode X on Map Y.  Activity Definitions tell a great deal of information about what *could* be relevant to a user: what rewards they can earn, what challenges could be performed, what modifiers could be applied. To figure out which of these properties is actually live, you&#39;ll need to combine the definition with \&quot;Live\&quot; data from one of the Destiny endpoints.  Activities also have Activity Types, but unfortunately in Destiny 2 these are even less reliable of a source of information than they were in Destiny 1. I will be looking into ways to provide more reliable sources for type information as time goes on, but for now we&#39;re going to have to deal with the limitations. See DestinyActivityTypeDefinition for more information.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyActivityDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyActivityDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'display_properties' => 'DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition',
        'original_display_properties' => 'DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition',
        'selection_screen_display_properties' => 'DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition',
        'release_icon' => 'string',
        'release_time' => 'int',
        'activity_level' => 'int',
        'activity_light_level' => 'int',
        'destination_hash' => 'int',
        'place_hash' => 'int',
        'activity_type_hash' => 'int',
        'tier' => 'int',
        'pgcr_image' => 'string',
        'rewards' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityRewardDefinition[]',
        'modifiers' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityModifierReferenceDefinition[]',
        'is_playlist' => 'bool',
        'challenges' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityChallengeDefinition[]',
        'optional_unlock_strings' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityUnlockStringDefinition[]',
        'playlist_items' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityPlaylistItemDefinition[]',
        'activity_graph_list' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityGraphListEntryDefinition[]',
        'matchmaking' => 'DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition',
        'guided_game' => 'DestinyDefinitionsDestinyActivityGuidedBlockDefinition',
        'direct_activity_mode_hash' => 'int',
        'direct_activity_mode_type' => 'int',
        'loadouts' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityLoadoutRequirementSet[]',
        'activity_mode_hashes' => 'int[]',
        'activity_mode_types' => 'int[]',
        'is_pv_p' => 'bool',
        'insertion_points' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityInsertionPointDefinition[]',
        'activity_location_mappings' => '\OpenAPI\Client\Model\DestinyConstantsDestinyEnvironmentLocationMapping[]',
        'hash' => 'int',
        'index' => 'int',
        'redacted' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'display_properties' => null,
        'original_display_properties' => null,
        'selection_screen_display_properties' => null,
        'release_icon' => null,
        'release_time' => 'int32',
        'activity_level' => 'int32',
        'activity_light_level' => 'int32',
        'destination_hash' => 'uint32',
        'place_hash' => 'uint32',
        'activity_type_hash' => 'uint32',
        'tier' => 'int32',
        'pgcr_image' => null,
        'rewards' => null,
        'modifiers' => null,
        'is_playlist' => null,
        'challenges' => null,
        'optional_unlock_strings' => null,
        'playlist_items' => null,
        'activity_graph_list' => null,
        'matchmaking' => null,
        'guided_game' => null,
        'direct_activity_mode_hash' => 'uint32',
        'direct_activity_mode_type' => 'int32',
        'loadouts' => null,
        'activity_mode_hashes' => 'uint32',
        'activity_mode_types' => 'int32',
        'is_pv_p' => null,
        'insertion_points' => null,
        'activity_location_mappings' => null,
        'hash' => 'uint32',
        'index' => 'int32',
        'redacted' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'display_properties' => 'displayProperties',
        'original_display_properties' => 'originalDisplayProperties',
        'selection_screen_display_properties' => 'selectionScreenDisplayProperties',
        'release_icon' => 'releaseIcon',
        'release_time' => 'releaseTime',
        'activity_level' => 'activityLevel',
        'activity_light_level' => 'activityLightLevel',
        'destination_hash' => 'destinationHash',
        'place_hash' => 'placeHash',
        'activity_type_hash' => 'activityTypeHash',
        'tier' => 'tier',
        'pgcr_image' => 'pgcrImage',
        'rewards' => 'rewards',
        'modifiers' => 'modifiers',
        'is_playlist' => 'isPlaylist',
        'challenges' => 'challenges',
        'optional_unlock_strings' => 'optionalUnlockStrings',
        'playlist_items' => 'playlistItems',
        'activity_graph_list' => 'activityGraphList',
        'matchmaking' => 'matchmaking',
        'guided_game' => 'guidedGame',
        'direct_activity_mode_hash' => 'directActivityModeHash',
        'direct_activity_mode_type' => 'directActivityModeType',
        'loadouts' => 'loadouts',
        'activity_mode_hashes' => 'activityModeHashes',
        'activity_mode_types' => 'activityModeTypes',
        'is_pv_p' => 'isPvP',
        'insertion_points' => 'insertionPoints',
        'activity_location_mappings' => 'activityLocationMappings',
        'hash' => 'hash',
        'index' => 'index',
        'redacted' => 'redacted'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'display_properties' => 'setDisplayProperties',
        'original_display_properties' => 'setOriginalDisplayProperties',
        'selection_screen_display_properties' => 'setSelectionScreenDisplayProperties',
        'release_icon' => 'setReleaseIcon',
        'release_time' => 'setReleaseTime',
        'activity_level' => 'setActivityLevel',
        'activity_light_level' => 'setActivityLightLevel',
        'destination_hash' => 'setDestinationHash',
        'place_hash' => 'setPlaceHash',
        'activity_type_hash' => 'setActivityTypeHash',
        'tier' => 'setTier',
        'pgcr_image' => 'setPgcrImage',
        'rewards' => 'setRewards',
        'modifiers' => 'setModifiers',
        'is_playlist' => 'setIsPlaylist',
        'challenges' => 'setChallenges',
        'optional_unlock_strings' => 'setOptionalUnlockStrings',
        'playlist_items' => 'setPlaylistItems',
        'activity_graph_list' => 'setActivityGraphList',
        'matchmaking' => 'setMatchmaking',
        'guided_game' => 'setGuidedGame',
        'direct_activity_mode_hash' => 'setDirectActivityModeHash',
        'direct_activity_mode_type' => 'setDirectActivityModeType',
        'loadouts' => 'setLoadouts',
        'activity_mode_hashes' => 'setActivityModeHashes',
        'activity_mode_types' => 'setActivityModeTypes',
        'is_pv_p' => 'setIsPvP',
        'insertion_points' => 'setInsertionPoints',
        'activity_location_mappings' => 'setActivityLocationMappings',
        'hash' => 'setHash',
        'index' => 'setIndex',
        'redacted' => 'setRedacted'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'display_properties' => 'getDisplayProperties',
        'original_display_properties' => 'getOriginalDisplayProperties',
        'selection_screen_display_properties' => 'getSelectionScreenDisplayProperties',
        'release_icon' => 'getReleaseIcon',
        'release_time' => 'getReleaseTime',
        'activity_level' => 'getActivityLevel',
        'activity_light_level' => 'getActivityLightLevel',
        'destination_hash' => 'getDestinationHash',
        'place_hash' => 'getPlaceHash',
        'activity_type_hash' => 'getActivityTypeHash',
        'tier' => 'getTier',
        'pgcr_image' => 'getPgcrImage',
        'rewards' => 'getRewards',
        'modifiers' => 'getModifiers',
        'is_playlist' => 'getIsPlaylist',
        'challenges' => 'getChallenges',
        'optional_unlock_strings' => 'getOptionalUnlockStrings',
        'playlist_items' => 'getPlaylistItems',
        'activity_graph_list' => 'getActivityGraphList',
        'matchmaking' => 'getMatchmaking',
        'guided_game' => 'getGuidedGame',
        'direct_activity_mode_hash' => 'getDirectActivityModeHash',
        'direct_activity_mode_type' => 'getDirectActivityModeType',
        'loadouts' => 'getLoadouts',
        'activity_mode_hashes' => 'getActivityModeHashes',
        'activity_mode_types' => 'getActivityModeTypes',
        'is_pv_p' => 'getIsPvP',
        'insertion_points' => 'getInsertionPoints',
        'activity_location_mappings' => 'getActivityLocationMappings',
        'hash' => 'getHash',
        'index' => 'getIndex',
        'redacted' => 'getRedacted'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const DIRECT_ACTIVITY_MODE_TYPE_0 = 0;
    const DIRECT_ACTIVITY_MODE_TYPE_2 = 2;
    const DIRECT_ACTIVITY_MODE_TYPE_3 = 3;
    const DIRECT_ACTIVITY_MODE_TYPE_4 = 4;
    const DIRECT_ACTIVITY_MODE_TYPE_5 = 5;
    const DIRECT_ACTIVITY_MODE_TYPE_6 = 6;
    const DIRECT_ACTIVITY_MODE_TYPE_7 = 7;
    const DIRECT_ACTIVITY_MODE_TYPE_9 = 9;
    const DIRECT_ACTIVITY_MODE_TYPE_10 = 10;
    const DIRECT_ACTIVITY_MODE_TYPE_11 = 11;
    const DIRECT_ACTIVITY_MODE_TYPE_12 = 12;
    const DIRECT_ACTIVITY_MODE_TYPE_13 = 13;
    const DIRECT_ACTIVITY_MODE_TYPE_15 = 15;
    const DIRECT_ACTIVITY_MODE_TYPE_16 = 16;
    const DIRECT_ACTIVITY_MODE_TYPE_17 = 17;
    const DIRECT_ACTIVITY_MODE_TYPE_18 = 18;
    const DIRECT_ACTIVITY_MODE_TYPE_19 = 19;
    const DIRECT_ACTIVITY_MODE_TYPE_20 = 20;
    const DIRECT_ACTIVITY_MODE_TYPE_21 = 21;
    const DIRECT_ACTIVITY_MODE_TYPE_22 = 22;
    const DIRECT_ACTIVITY_MODE_TYPE_24 = 24;
    const DIRECT_ACTIVITY_MODE_TYPE_25 = 25;
    const DIRECT_ACTIVITY_MODE_TYPE_26 = 26;
    const DIRECT_ACTIVITY_MODE_TYPE_27 = 27;
    const DIRECT_ACTIVITY_MODE_TYPE_28 = 28;
    const DIRECT_ACTIVITY_MODE_TYPE_29 = 29;
    const DIRECT_ACTIVITY_MODE_TYPE_30 = 30;
    const DIRECT_ACTIVITY_MODE_TYPE_31 = 31;
    const DIRECT_ACTIVITY_MODE_TYPE_32 = 32;
    const DIRECT_ACTIVITY_MODE_TYPE_37 = 37;
    const DIRECT_ACTIVITY_MODE_TYPE_38 = 38;
    const DIRECT_ACTIVITY_MODE_TYPE_39 = 39;
    const DIRECT_ACTIVITY_MODE_TYPE_40 = 40;
    const DIRECT_ACTIVITY_MODE_TYPE_41 = 41;
    const DIRECT_ACTIVITY_MODE_TYPE_42 = 42;
    const DIRECT_ACTIVITY_MODE_TYPE_43 = 43;
    const DIRECT_ACTIVITY_MODE_TYPE_44 = 44;
    const DIRECT_ACTIVITY_MODE_TYPE_45 = 45;
    const DIRECT_ACTIVITY_MODE_TYPE_46 = 46;
    const DIRECT_ACTIVITY_MODE_TYPE_47 = 47;
    const DIRECT_ACTIVITY_MODE_TYPE_48 = 48;
    const DIRECT_ACTIVITY_MODE_TYPE_49 = 49;
    const DIRECT_ACTIVITY_MODE_TYPE_50 = 50;
    const DIRECT_ACTIVITY_MODE_TYPE_51 = 51;
    const DIRECT_ACTIVITY_MODE_TYPE_52 = 52;
    const DIRECT_ACTIVITY_MODE_TYPE_53 = 53;
    const DIRECT_ACTIVITY_MODE_TYPE_54 = 54;
    const DIRECT_ACTIVITY_MODE_TYPE_55 = 55;
    const DIRECT_ACTIVITY_MODE_TYPE_56 = 56;
    const DIRECT_ACTIVITY_MODE_TYPE_57 = 57;
    const DIRECT_ACTIVITY_MODE_TYPE_58 = 58;
    const DIRECT_ACTIVITY_MODE_TYPE_59 = 59;
    const DIRECT_ACTIVITY_MODE_TYPE_60 = 60;
    const DIRECT_ACTIVITY_MODE_TYPE_61 = 61;
    const DIRECT_ACTIVITY_MODE_TYPE_62 = 62;
    const DIRECT_ACTIVITY_MODE_TYPE_63 = 63;
    const DIRECT_ACTIVITY_MODE_TYPE_64 = 64;
    const DIRECT_ACTIVITY_MODE_TYPE_65 = 65;
    const DIRECT_ACTIVITY_MODE_TYPE_66 = 66;
    const DIRECT_ACTIVITY_MODE_TYPE_67 = 67;
    const DIRECT_ACTIVITY_MODE_TYPE_68 = 68;
    const DIRECT_ACTIVITY_MODE_TYPE_69 = 69;
    const DIRECT_ACTIVITY_MODE_TYPE_70 = 70;
    const DIRECT_ACTIVITY_MODE_TYPE_71 = 71;
    const DIRECT_ACTIVITY_MODE_TYPE_72 = 72;
    const DIRECT_ACTIVITY_MODE_TYPE_73 = 73;
    const DIRECT_ACTIVITY_MODE_TYPE_74 = 74;
    const DIRECT_ACTIVITY_MODE_TYPE_75 = 75;
    const DIRECT_ACTIVITY_MODE_TYPE_76 = 76;
    const DIRECT_ACTIVITY_MODE_TYPE_77 = 77;
    const DIRECT_ACTIVITY_MODE_TYPE_78 = 78;
    const DIRECT_ACTIVITY_MODE_TYPE_79 = 79;
    const DIRECT_ACTIVITY_MODE_TYPE_80 = 80;
    const DIRECT_ACTIVITY_MODE_TYPE_81 = 81;
    const DIRECT_ACTIVITY_MODE_TYPE_82 = 82;
    const DIRECT_ACTIVITY_MODE_TYPE_83 = 83;
    const DIRECT_ACTIVITY_MODE_TYPE_84 = 84;
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDirectActivityModeTypeAllowableValues()
    {
        return [
            self::DIRECT_ACTIVITY_MODE_TYPE_0,
            self::DIRECT_ACTIVITY_MODE_TYPE_2,
            self::DIRECT_ACTIVITY_MODE_TYPE_3,
            self::DIRECT_ACTIVITY_MODE_TYPE_4,
            self::DIRECT_ACTIVITY_MODE_TYPE_5,
            self::DIRECT_ACTIVITY_MODE_TYPE_6,
            self::DIRECT_ACTIVITY_MODE_TYPE_7,
            self::DIRECT_ACTIVITY_MODE_TYPE_9,
            self::DIRECT_ACTIVITY_MODE_TYPE_10,
            self::DIRECT_ACTIVITY_MODE_TYPE_11,
            self::DIRECT_ACTIVITY_MODE_TYPE_12,
            self::DIRECT_ACTIVITY_MODE_TYPE_13,
            self::DIRECT_ACTIVITY_MODE_TYPE_15,
            self::DIRECT_ACTIVITY_MODE_TYPE_16,
            self::DIRECT_ACTIVITY_MODE_TYPE_17,
            self::DIRECT_ACTIVITY_MODE_TYPE_18,
            self::DIRECT_ACTIVITY_MODE_TYPE_19,
            self::DIRECT_ACTIVITY_MODE_TYPE_20,
            self::DIRECT_ACTIVITY_MODE_TYPE_21,
            self::DIRECT_ACTIVITY_MODE_TYPE_22,
            self::DIRECT_ACTIVITY_MODE_TYPE_24,
            self::DIRECT_ACTIVITY_MODE_TYPE_25,
            self::DIRECT_ACTIVITY_MODE_TYPE_26,
            self::DIRECT_ACTIVITY_MODE_TYPE_27,
            self::DIRECT_ACTIVITY_MODE_TYPE_28,
            self::DIRECT_ACTIVITY_MODE_TYPE_29,
            self::DIRECT_ACTIVITY_MODE_TYPE_30,
            self::DIRECT_ACTIVITY_MODE_TYPE_31,
            self::DIRECT_ACTIVITY_MODE_TYPE_32,
            self::DIRECT_ACTIVITY_MODE_TYPE_37,
            self::DIRECT_ACTIVITY_MODE_TYPE_38,
            self::DIRECT_ACTIVITY_MODE_TYPE_39,
            self::DIRECT_ACTIVITY_MODE_TYPE_40,
            self::DIRECT_ACTIVITY_MODE_TYPE_41,
            self::DIRECT_ACTIVITY_MODE_TYPE_42,
            self::DIRECT_ACTIVITY_MODE_TYPE_43,
            self::DIRECT_ACTIVITY_MODE_TYPE_44,
            self::DIRECT_ACTIVITY_MODE_TYPE_45,
            self::DIRECT_ACTIVITY_MODE_TYPE_46,
            self::DIRECT_ACTIVITY_MODE_TYPE_47,
            self::DIRECT_ACTIVITY_MODE_TYPE_48,
            self::DIRECT_ACTIVITY_MODE_TYPE_49,
            self::DIRECT_ACTIVITY_MODE_TYPE_50,
            self::DIRECT_ACTIVITY_MODE_TYPE_51,
            self::DIRECT_ACTIVITY_MODE_TYPE_52,
            self::DIRECT_ACTIVITY_MODE_TYPE_53,
            self::DIRECT_ACTIVITY_MODE_TYPE_54,
            self::DIRECT_ACTIVITY_MODE_TYPE_55,
            self::DIRECT_ACTIVITY_MODE_TYPE_56,
            self::DIRECT_ACTIVITY_MODE_TYPE_57,
            self::DIRECT_ACTIVITY_MODE_TYPE_58,
            self::DIRECT_ACTIVITY_MODE_TYPE_59,
            self::DIRECT_ACTIVITY_MODE_TYPE_60,
            self::DIRECT_ACTIVITY_MODE_TYPE_61,
            self::DIRECT_ACTIVITY_MODE_TYPE_62,
            self::DIRECT_ACTIVITY_MODE_TYPE_63,
            self::DIRECT_ACTIVITY_MODE_TYPE_64,
            self::DIRECT_ACTIVITY_MODE_TYPE_65,
            self::DIRECT_ACTIVITY_MODE_TYPE_66,
            self::DIRECT_ACTIVITY_MODE_TYPE_67,
            self::DIRECT_ACTIVITY_MODE_TYPE_68,
            self::DIRECT_ACTIVITY_MODE_TYPE_69,
            self::DIRECT_ACTIVITY_MODE_TYPE_70,
            self::DIRECT_ACTIVITY_MODE_TYPE_71,
            self::DIRECT_ACTIVITY_MODE_TYPE_72,
            self::DIRECT_ACTIVITY_MODE_TYPE_73,
            self::DIRECT_ACTIVITY_MODE_TYPE_74,
            self::DIRECT_ACTIVITY_MODE_TYPE_75,
            self::DIRECT_ACTIVITY_MODE_TYPE_76,
            self::DIRECT_ACTIVITY_MODE_TYPE_77,
            self::DIRECT_ACTIVITY_MODE_TYPE_78,
            self::DIRECT_ACTIVITY_MODE_TYPE_79,
            self::DIRECT_ACTIVITY_MODE_TYPE_80,
            self::DIRECT_ACTIVITY_MODE_TYPE_81,
            self::DIRECT_ACTIVITY_MODE_TYPE_82,
            self::DIRECT_ACTIVITY_MODE_TYPE_83,
            self::DIRECT_ACTIVITY_MODE_TYPE_84,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['display_properties'] = $data['display_properties'] ?? null;
        $this->container['original_display_properties'] = $data['original_display_properties'] ?? null;
        $this->container['selection_screen_display_properties'] = $data['selection_screen_display_properties'] ?? null;
        $this->container['release_icon'] = $data['release_icon'] ?? null;
        $this->container['release_time'] = $data['release_time'] ?? null;
        $this->container['activity_level'] = $data['activity_level'] ?? null;
        $this->container['activity_light_level'] = $data['activity_light_level'] ?? null;
        $this->container['destination_hash'] = $data['destination_hash'] ?? null;
        $this->container['place_hash'] = $data['place_hash'] ?? null;
        $this->container['activity_type_hash'] = $data['activity_type_hash'] ?? null;
        $this->container['tier'] = $data['tier'] ?? null;
        $this->container['pgcr_image'] = $data['pgcr_image'] ?? null;
        $this->container['rewards'] = $data['rewards'] ?? null;
        $this->container['modifiers'] = $data['modifiers'] ?? null;
        $this->container['is_playlist'] = $data['is_playlist'] ?? null;
        $this->container['challenges'] = $data['challenges'] ?? null;
        $this->container['optional_unlock_strings'] = $data['optional_unlock_strings'] ?? null;
        $this->container['playlist_items'] = $data['playlist_items'] ?? null;
        $this->container['activity_graph_list'] = $data['activity_graph_list'] ?? null;
        $this->container['matchmaking'] = $data['matchmaking'] ?? null;
        $this->container['guided_game'] = $data['guided_game'] ?? null;
        $this->container['direct_activity_mode_hash'] = $data['direct_activity_mode_hash'] ?? null;
        $this->container['direct_activity_mode_type'] = $data['direct_activity_mode_type'] ?? null;
        $this->container['loadouts'] = $data['loadouts'] ?? null;
        $this->container['activity_mode_hashes'] = $data['activity_mode_hashes'] ?? null;
        $this->container['activity_mode_types'] = $data['activity_mode_types'] ?? null;
        $this->container['is_pv_p'] = $data['is_pv_p'] ?? null;
        $this->container['insertion_points'] = $data['insertion_points'] ?? null;
        $this->container['activity_location_mappings'] = $data['activity_location_mappings'] ?? null;
        $this->container['hash'] = $data['hash'] ?? null;
        $this->container['index'] = $data['index'] ?? null;
        $this->container['redacted'] = $data['redacted'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDirectActivityModeTypeAllowableValues();
        if (!is_null($this->container['direct_activity_mode_type']) && !in_array($this->container['direct_activity_mode_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'direct_activity_mode_type', must be one of '%s'",
                $this->container['direct_activity_mode_type'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets display_properties
     *
     * @return DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null
     */
    public function getDisplayProperties()
    {
        return $this->container['display_properties'];
    }

    /**
     * Sets display_properties
     *
     * @param DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null $display_properties The title, subtitle, and icon for the activity. We do a little post-processing on this to try and account for Activities where the designers have left this data too minimal to determine what activity is actually being played.
     *
     * @return self
     */
    public function setDisplayProperties($display_properties)
    {
        $this->container['display_properties'] = $display_properties;

        return $this;
    }

    /**
     * Gets original_display_properties
     *
     * @return DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null
     */
    public function getOriginalDisplayProperties()
    {
        return $this->container['original_display_properties'];
    }

    /**
     * Sets original_display_properties
     *
     * @param DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null $original_display_properties The unadulterated form of the display properties, as they ought to be shown in the Director (if the activity appears in the director).
     *
     * @return self
     */
    public function setOriginalDisplayProperties($original_display_properties)
    {
        $this->container['original_display_properties'] = $original_display_properties;

        return $this;
    }

    /**
     * Gets selection_screen_display_properties
     *
     * @return DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null
     */
    public function getSelectionScreenDisplayProperties()
    {
        return $this->container['selection_screen_display_properties'];
    }

    /**
     * Sets selection_screen_display_properties
     *
     * @param DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null $selection_screen_display_properties The title, subtitle, and icon for the activity as determined by Selection Screen data, if there is any for this activity. There won't be data in this field if the activity is never shown in a selection/options screen.
     *
     * @return self
     */
    public function setSelectionScreenDisplayProperties($selection_screen_display_properties)
    {
        $this->container['selection_screen_display_properties'] = $selection_screen_display_properties;

        return $this;
    }

    /**
     * Gets release_icon
     *
     * @return string|null
     */
    public function getReleaseIcon()
    {
        return $this->container['release_icon'];
    }

    /**
     * Sets release_icon
     *
     * @param string|null $release_icon If the activity has an icon associated with a specific release (such as a DLC), this is the path to that release's icon.
     *
     * @return self
     */
    public function setReleaseIcon($release_icon)
    {
        $this->container['release_icon'] = $release_icon;

        return $this;
    }

    /**
     * Gets release_time
     *
     * @return int|null
     */
    public function getReleaseTime()
    {
        return $this->container['release_time'];
    }

    /**
     * Sets release_time
     *
     * @param int|null $release_time If the activity will not be visible until a specific and known time, this will be the seconds since the Epoch when it will become visible.
     *
     * @return self
     */
    public function setReleaseTime($release_time)
    {
        $this->container['release_time'] = $release_time;

        return $this;
    }

    /**
     * Gets activity_level
     *
     * @return int|null
     */
    public function getActivityLevel()
    {
        return $this->container['activity_level'];
    }

    /**
     * Sets activity_level
     *
     * @param int|null $activity_level The difficulty level of the activity.
     *
     * @return self
     */
    public function setActivityLevel($activity_level)
    {
        $this->container['activity_level'] = $activity_level;

        return $this;
    }

    /**
     * Gets activity_light_level
     *
     * @return int|null
     */
    public function getActivityLightLevel()
    {
        return $this->container['activity_light_level'];
    }

    /**
     * Sets activity_light_level
     *
     * @param int|null $activity_light_level The recommended light level for this activity.
     *
     * @return self
     */
    public function setActivityLightLevel($activity_light_level)
    {
        $this->container['activity_light_level'] = $activity_light_level;

        return $this;
    }

    /**
     * Gets destination_hash
     *
     * @return int|null
     */
    public function getDestinationHash()
    {
        return $this->container['destination_hash'];
    }

    /**
     * Sets destination_hash
     *
     * @param int|null $destination_hash The hash identifier for the Destination on which this Activity is played. Use it to look up the DestinyDestinationDefinition for human readable info about the destination. A Destination can be thought of as a more specific location than a \"Place\". For instance, if the \"Place\" is Earth, the \"Destination\" would be a specific city or region on Earth.
     *
     * @return self
     */
    public function setDestinationHash($destination_hash)
    {
        $this->container['destination_hash'] = $destination_hash;

        return $this;
    }

    /**
     * Gets place_hash
     *
     * @return int|null
     */
    public function getPlaceHash()
    {
        return $this->container['place_hash'];
    }

    /**
     * Sets place_hash
     *
     * @param int|null $place_hash The hash identifier for the \"Place\" on which this Activity is played. Use it to look up the DestinyPlaceDefinition for human readable info about the Place. A Place is the largest-scoped concept for location information. For instance, if the \"Place\" is Earth, the \"Destination\" would be a specific city or region on Earth.
     *
     * @return self
     */
    public function setPlaceHash($place_hash)
    {
        $this->container['place_hash'] = $place_hash;

        return $this;
    }

    /**
     * Gets activity_type_hash
     *
     * @return int|null
     */
    public function getActivityTypeHash()
    {
        return $this->container['activity_type_hash'];
    }

    /**
     * Sets activity_type_hash
     *
     * @param int|null $activity_type_hash The hash identifier for the Activity Type of this Activity. You may use it to look up the DestinyActivityTypeDefinition for human readable info, but be forewarned: Playlists and many PVP Map Activities will map to generic Activity Types. You'll have to use your knowledge of the Activity Mode being played to get more specific information about what the user is playing.
     *
     * @return self
     */
    public function setActivityTypeHash($activity_type_hash)
    {
        $this->container['activity_type_hash'] = $activity_type_hash;

        return $this;
    }

    /**
     * Gets tier
     *
     * @return int|null
     */
    public function getTier()
    {
        return $this->container['tier'];
    }

    /**
     * Sets tier
     *
     * @param int|null $tier The difficulty tier of the activity.
     *
     * @return self
     */
    public function setTier($tier)
    {
        $this->container['tier'] = $tier;

        return $this;
    }

    /**
     * Gets pgcr_image
     *
     * @return string|null
     */
    public function getPgcrImage()
    {
        return $this->container['pgcr_image'];
    }

    /**
     * Sets pgcr_image
     *
     * @param string|null $pgcr_image When Activities are completed, we generate a \"Post-Game Carnage Report\", or PGCR, with details about what happened in that activity (how many kills someone got, which team won, etc...) We use this image as the background when displaying PGCR information, and often use it when we refer to the Activity in general.
     *
     * @return self
     */
    public function setPgcrImage($pgcr_image)
    {
        $this->container['pgcr_image'] = $pgcr_image;

        return $this;
    }

    /**
     * Gets rewards
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityRewardDefinition[]|null
     */
    public function getRewards()
    {
        return $this->container['rewards'];
    }

    /**
     * Sets rewards
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityRewardDefinition[]|null $rewards The expected possible rewards for the activity. These rewards may or may not be accessible for an individual player based on their character state, the account state, and even the game's state overall. But it is a useful reference for possible rewards you can earn in the activity. These match up to rewards displayed when you hover over the Activity in the in-game Director, and often refer to Placeholder or \"Dummy\" items: items that tell you what you can earn in vague terms rather than what you'll specifically be earning (partly because the game doesn't even know what you'll earn specifically until you roll for it at the end)
     *
     * @return self
     */
    public function setRewards($rewards)
    {
        $this->container['rewards'] = $rewards;

        return $this;
    }

    /**
     * Gets modifiers
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityModifierReferenceDefinition[]|null
     */
    public function getModifiers()
    {
        return $this->container['modifiers'];
    }

    /**
     * Sets modifiers
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityModifierReferenceDefinition[]|null $modifiers Activities can have Modifiers, as defined in DestinyActivityModifierDefinition. These are references to the modifiers that *can* be applied to that activity, along with data that we use to determine if that modifier is actually active at any given point in time.
     *
     * @return self
     */
    public function setModifiers($modifiers)
    {
        $this->container['modifiers'] = $modifiers;

        return $this;
    }

    /**
     * Gets is_playlist
     *
     * @return bool|null
     */
    public function getIsPlaylist()
    {
        return $this->container['is_playlist'];
    }

    /**
     * Sets is_playlist
     *
     * @param bool|null $is_playlist If True, this Activity is actually a Playlist that refers to multiple possible specific Activities and Activity Modes. For instance, a Crucible Playlist may have references to multiple Activities (Maps) with multiple Activity Modes (specific PvP gameplay modes). If this is true, refer to the playlistItems property for the specific entries in the playlist.
     *
     * @return self
     */
    public function setIsPlaylist($is_playlist)
    {
        $this->container['is_playlist'] = $is_playlist;

        return $this;
    }

    /**
     * Gets challenges
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityChallengeDefinition[]|null
     */
    public function getChallenges()
    {
        return $this->container['challenges'];
    }

    /**
     * Sets challenges
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityChallengeDefinition[]|null $challenges An activity can have many Challenges, of which any subset of them may be active for play at any given period of time. This gives the information about the challenges and data that we use to understand when they're active and what rewards they provide. Sadly, at the moment there's no central definition for challenges: much like \"Skulls\" were in Destiny 1, these are defined on individual activities and there can be many duplicates/near duplicates across the Destiny 2 ecosystem. I have it in mind to centralize these in a future revision of the API, but we are out of time.
     *
     * @return self
     */
    public function setChallenges($challenges)
    {
        $this->container['challenges'] = $challenges;

        return $this;
    }

    /**
     * Gets optional_unlock_strings
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityUnlockStringDefinition[]|null
     */
    public function getOptionalUnlockStrings()
    {
        return $this->container['optional_unlock_strings'];
    }

    /**
     * Sets optional_unlock_strings
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityUnlockStringDefinition[]|null $optional_unlock_strings If there are status strings related to the activity and based on internal state of the game, account, or character, then this will be the definition of those strings and the states needed in order for the strings to be shown.
     *
     * @return self
     */
    public function setOptionalUnlockStrings($optional_unlock_strings)
    {
        $this->container['optional_unlock_strings'] = $optional_unlock_strings;

        return $this;
    }

    /**
     * Gets playlist_items
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityPlaylistItemDefinition[]|null
     */
    public function getPlaylistItems()
    {
        return $this->container['playlist_items'];
    }

    /**
     * Sets playlist_items
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityPlaylistItemDefinition[]|null $playlist_items Represents all of the possible activities that could be played in the Playlist, along with information that we can use to determine if they are active at the present time.
     *
     * @return self
     */
    public function setPlaylistItems($playlist_items)
    {
        $this->container['playlist_items'] = $playlist_items;

        return $this;
    }

    /**
     * Gets activity_graph_list
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityGraphListEntryDefinition[]|null
     */
    public function getActivityGraphList()
    {
        return $this->container['activity_graph_list'];
    }

    /**
     * Sets activity_graph_list
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityGraphListEntryDefinition[]|null $activity_graph_list Unfortunately, in practice this is almost never populated. In theory, this is supposed to tell which Activity Graph to show if you bring up the director while in this activity.
     *
     * @return self
     */
    public function setActivityGraphList($activity_graph_list)
    {
        $this->container['activity_graph_list'] = $activity_graph_list;

        return $this;
    }

    /**
     * Gets matchmaking
     *
     * @return DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition|null
     */
    public function getMatchmaking()
    {
        return $this->container['matchmaking'];
    }

    /**
     * Sets matchmaking
     *
     * @param DestinyDefinitionsDestinyActivityMatchmakingBlockDefinition|null $matchmaking This block of data provides information about the Activity's matchmaking attributes: how many people can join and such.
     *
     * @return self
     */
    public function setMatchmaking($matchmaking)
    {
        $this->container['matchmaking'] = $matchmaking;

        return $this;
    }

    /**
     * Gets guided_game
     *
     * @return DestinyDefinitionsDestinyActivityGuidedBlockDefinition|null
     */
    public function getGuidedGame()
    {
        return $this->container['guided_game'];
    }

    /**
     * Sets guided_game
     *
     * @param DestinyDefinitionsDestinyActivityGuidedBlockDefinition|null $guided_game This block of data, if it exists, provides information about the guided game experience and restrictions for this activity. If it doesn't exist, the game is not able to be played as a guided game.
     *
     * @return self
     */
    public function setGuidedGame($guided_game)
    {
        $this->container['guided_game'] = $guided_game;

        return $this;
    }

    /**
     * Gets direct_activity_mode_hash
     *
     * @return int|null
     */
    public function getDirectActivityModeHash()
    {
        return $this->container['direct_activity_mode_hash'];
    }

    /**
     * Sets direct_activity_mode_hash
     *
     * @param int|null $direct_activity_mode_hash If this activity had an activity mode directly defined on it, this will be the hash of that mode.
     *
     * @return self
     */
    public function setDirectActivityModeHash($direct_activity_mode_hash)
    {
        $this->container['direct_activity_mode_hash'] = $direct_activity_mode_hash;

        return $this;
    }

    /**
     * Gets direct_activity_mode_type
     *
     * @return int|null
     */
    public function getDirectActivityModeType()
    {
        return $this->container['direct_activity_mode_type'];
    }

    /**
     * Sets direct_activity_mode_type
     *
     * @param int|null $direct_activity_mode_type If the activity had an activity mode directly defined on it, this will be the enum value of that mode.
     *
     * @return self
     */
    public function setDirectActivityModeType($direct_activity_mode_type)
    {
        $allowedValues = $this->getDirectActivityModeTypeAllowableValues();
        if (!is_null($direct_activity_mode_type) && !in_array($direct_activity_mode_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'direct_activity_mode_type', must be one of '%s'",
                    $direct_activity_mode_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['direct_activity_mode_type'] = $direct_activity_mode_type;

        return $this;
    }

    /**
     * Gets loadouts
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityLoadoutRequirementSet[]|null
     */
    public function getLoadouts()
    {
        return $this->container['loadouts'];
    }

    /**
     * Sets loadouts
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityLoadoutRequirementSet[]|null $loadouts The set of all possible loadout requirements that could be active for this activity. Only one will be active at any given time, and you can discover which one through activity-associated data such as Milestones that have activity info on them.
     *
     * @return self
     */
    public function setLoadouts($loadouts)
    {
        $this->container['loadouts'] = $loadouts;

        return $this;
    }

    /**
     * Gets activity_mode_hashes
     *
     * @return int[]|null
     */
    public function getActivityModeHashes()
    {
        return $this->container['activity_mode_hashes'];
    }

    /**
     * Sets activity_mode_hashes
     *
     * @param int[]|null $activity_mode_hashes The hash identifiers for Activity Modes relevant to this activity.  Note that if this is a playlist, the specific playlist entry chosen will determine the actual activity modes that end up being relevant.
     *
     * @return self
     */
    public function setActivityModeHashes($activity_mode_hashes)
    {
        $this->container['activity_mode_hashes'] = $activity_mode_hashes;

        return $this;
    }

    /**
     * Gets activity_mode_types
     *
     * @return int[]|null
     */
    public function getActivityModeTypes()
    {
        return $this->container['activity_mode_types'];
    }

    /**
     * Sets activity_mode_types
     *
     * @param int[]|null $activity_mode_types The activity modes - if any - in enum form. Because we can't seem to escape the enums.
     *
     * @return self
     */
    public function setActivityModeTypes($activity_mode_types)
    {
        $this->container['activity_mode_types'] = $activity_mode_types;

        return $this;
    }

    /**
     * Gets is_pv_p
     *
     * @return bool|null
     */
    public function getIsPvP()
    {
        return $this->container['is_pv_p'];
    }

    /**
     * Sets is_pv_p
     *
     * @param bool|null $is_pv_p If true, this activity is a PVP activity or playlist.
     *
     * @return self
     */
    public function setIsPvP($is_pv_p)
    {
        $this->container['is_pv_p'] = $is_pv_p;

        return $this;
    }

    /**
     * Gets insertion_points
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityInsertionPointDefinition[]|null
     */
    public function getInsertionPoints()
    {
        return $this->container['insertion_points'];
    }

    /**
     * Sets insertion_points
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyActivityInsertionPointDefinition[]|null $insertion_points The list of phases or points of entry into an activity, along with information we can use to determine their gating and availability.
     *
     * @return self
     */
    public function setInsertionPoints($insertion_points)
    {
        $this->container['insertion_points'] = $insertion_points;

        return $this;
    }

    /**
     * Gets activity_location_mappings
     *
     * @return \OpenAPI\Client\Model\DestinyConstantsDestinyEnvironmentLocationMapping[]|null
     */
    public function getActivityLocationMappings()
    {
        return $this->container['activity_location_mappings'];
    }

    /**
     * Sets activity_location_mappings
     *
     * @param \OpenAPI\Client\Model\DestinyConstantsDestinyEnvironmentLocationMapping[]|null $activity_location_mappings A list of location mappings that are affected by this activity. Pulled out of DestinyLocationDefinitions for our/your lookup convenience.
     *
     * @return self
     */
    public function setActivityLocationMappings($activity_location_mappings)
    {
        $this->container['activity_location_mappings'] = $activity_location_mappings;

        return $this;
    }

    /**
     * Gets hash
     *
     * @return int|null
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param int|null $hash The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
     *
     * @return self
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets index
     *
     * @return int|null
     */
    public function getIndex()
    {
        return $this->container['index'];
    }

    /**
     * Sets index
     *
     * @param int|null $index The index of the entity as it was found in the investment tables.
     *
     * @return self
     */
    public function setIndex($index)
    {
        $this->container['index'] = $index;

        return $this;
    }

    /**
     * Gets redacted
     *
     * @return bool|null
     */
    public function getRedacted()
    {
        return $this->container['redacted'];
    }

    /**
     * Sets redacted
     *
     * @param bool|null $redacted If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
     *
     * @return self
     */
    public function setRedacted($redacted)
    {
        $this->container['redacted'] = $redacted;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


