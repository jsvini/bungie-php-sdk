<?php
/**
 * DestinyDefinitionsDestinyTalentNodeDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyTalentNodeDefinition Class Doc Comment
 *
 * @category Class
 * @description Talent Grids on items have Nodes. These nodes have positions in the talent grid&#39;s UI, and contain \&quot;Steps\&quot; (DestinyTalentNodeStepDefinition), one of whom will be the \&quot;Current\&quot; step.  The Current Step determines the visual properties of the node, as well as what the node grants when it is activated.  See DestinyTalentGridDefinition for a more complete overview of how Talent Grids work, and how they are used in Destiny 2 (and how they were used in Destiny 1).
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyTalentNodeDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyTalentNodeDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'node_index' => 'int',
        'node_hash' => 'int',
        'row' => 'int',
        'column' => 'int',
        'prerequisite_node_indexes' => 'int[]',
        'binary_pair_node_index' => 'int',
        'auto_unlocks' => 'bool',
        'last_step_repeats' => 'bool',
        'is_random' => 'bool',
        'random_activation_requirement' => 'DestinyDefinitionsDestinyNodeActivationRequirement',
        'is_random_repurchasable' => 'bool',
        'steps' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyNodeStepDefinition[]',
        'exclusive_with_node_hashes' => 'int[]',
        'random_start_progression_bar_at_progression' => 'int',
        'layout_identifier' => 'string',
        'group_hash' => 'int',
        'lore_hash' => 'int',
        'node_style_identifier' => 'string',
        'ignore_for_completion' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'node_index' => 'int32',
        'node_hash' => 'uint32',
        'row' => 'int32',
        'column' => 'int32',
        'prerequisite_node_indexes' => 'int32',
        'binary_pair_node_index' => 'int32',
        'auto_unlocks' => null,
        'last_step_repeats' => null,
        'is_random' => null,
        'random_activation_requirement' => null,
        'is_random_repurchasable' => null,
        'steps' => null,
        'exclusive_with_node_hashes' => 'uint32',
        'random_start_progression_bar_at_progression' => 'int32',
        'layout_identifier' => null,
        'group_hash' => 'uint32',
        'lore_hash' => 'uint32',
        'node_style_identifier' => null,
        'ignore_for_completion' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'node_index' => 'nodeIndex',
        'node_hash' => 'nodeHash',
        'row' => 'row',
        'column' => 'column',
        'prerequisite_node_indexes' => 'prerequisiteNodeIndexes',
        'binary_pair_node_index' => 'binaryPairNodeIndex',
        'auto_unlocks' => 'autoUnlocks',
        'last_step_repeats' => 'lastStepRepeats',
        'is_random' => 'isRandom',
        'random_activation_requirement' => 'randomActivationRequirement',
        'is_random_repurchasable' => 'isRandomRepurchasable',
        'steps' => 'steps',
        'exclusive_with_node_hashes' => 'exclusiveWithNodeHashes',
        'random_start_progression_bar_at_progression' => 'randomStartProgressionBarAtProgression',
        'layout_identifier' => 'layoutIdentifier',
        'group_hash' => 'groupHash',
        'lore_hash' => 'loreHash',
        'node_style_identifier' => 'nodeStyleIdentifier',
        'ignore_for_completion' => 'ignoreForCompletion'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'node_index' => 'setNodeIndex',
        'node_hash' => 'setNodeHash',
        'row' => 'setRow',
        'column' => 'setColumn',
        'prerequisite_node_indexes' => 'setPrerequisiteNodeIndexes',
        'binary_pair_node_index' => 'setBinaryPairNodeIndex',
        'auto_unlocks' => 'setAutoUnlocks',
        'last_step_repeats' => 'setLastStepRepeats',
        'is_random' => 'setIsRandom',
        'random_activation_requirement' => 'setRandomActivationRequirement',
        'is_random_repurchasable' => 'setIsRandomRepurchasable',
        'steps' => 'setSteps',
        'exclusive_with_node_hashes' => 'setExclusiveWithNodeHashes',
        'random_start_progression_bar_at_progression' => 'setRandomStartProgressionBarAtProgression',
        'layout_identifier' => 'setLayoutIdentifier',
        'group_hash' => 'setGroupHash',
        'lore_hash' => 'setLoreHash',
        'node_style_identifier' => 'setNodeStyleIdentifier',
        'ignore_for_completion' => 'setIgnoreForCompletion'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'node_index' => 'getNodeIndex',
        'node_hash' => 'getNodeHash',
        'row' => 'getRow',
        'column' => 'getColumn',
        'prerequisite_node_indexes' => 'getPrerequisiteNodeIndexes',
        'binary_pair_node_index' => 'getBinaryPairNodeIndex',
        'auto_unlocks' => 'getAutoUnlocks',
        'last_step_repeats' => 'getLastStepRepeats',
        'is_random' => 'getIsRandom',
        'random_activation_requirement' => 'getRandomActivationRequirement',
        'is_random_repurchasable' => 'getIsRandomRepurchasable',
        'steps' => 'getSteps',
        'exclusive_with_node_hashes' => 'getExclusiveWithNodeHashes',
        'random_start_progression_bar_at_progression' => 'getRandomStartProgressionBarAtProgression',
        'layout_identifier' => 'getLayoutIdentifier',
        'group_hash' => 'getGroupHash',
        'lore_hash' => 'getLoreHash',
        'node_style_identifier' => 'getNodeStyleIdentifier',
        'ignore_for_completion' => 'getIgnoreForCompletion'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['node_index'] = $data['node_index'] ?? null;
        $this->container['node_hash'] = $data['node_hash'] ?? null;
        $this->container['row'] = $data['row'] ?? null;
        $this->container['column'] = $data['column'] ?? null;
        $this->container['prerequisite_node_indexes'] = $data['prerequisite_node_indexes'] ?? null;
        $this->container['binary_pair_node_index'] = $data['binary_pair_node_index'] ?? null;
        $this->container['auto_unlocks'] = $data['auto_unlocks'] ?? null;
        $this->container['last_step_repeats'] = $data['last_step_repeats'] ?? null;
        $this->container['is_random'] = $data['is_random'] ?? null;
        $this->container['random_activation_requirement'] = $data['random_activation_requirement'] ?? null;
        $this->container['is_random_repurchasable'] = $data['is_random_repurchasable'] ?? null;
        $this->container['steps'] = $data['steps'] ?? null;
        $this->container['exclusive_with_node_hashes'] = $data['exclusive_with_node_hashes'] ?? null;
        $this->container['random_start_progression_bar_at_progression'] = $data['random_start_progression_bar_at_progression'] ?? null;
        $this->container['layout_identifier'] = $data['layout_identifier'] ?? null;
        $this->container['group_hash'] = $data['group_hash'] ?? null;
        $this->container['lore_hash'] = $data['lore_hash'] ?? null;
        $this->container['node_style_identifier'] = $data['node_style_identifier'] ?? null;
        $this->container['ignore_for_completion'] = $data['ignore_for_completion'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets node_index
     *
     * @return int|null
     */
    public function getNodeIndex()
    {
        return $this->container['node_index'];
    }

    /**
     * Sets node_index
     *
     * @param int|null $node_index The index into the DestinyTalentGridDefinition's \"nodes\" property where this node is located. Used to uniquely identify the node within the Talent Grid. Note that this is content version dependent: make sure you have the latest version of content before trying to use these properties.
     *
     * @return self
     */
    public function setNodeIndex($node_index)
    {
        $this->container['node_index'] = $node_index;

        return $this;
    }

    /**
     * Gets node_hash
     *
     * @return int|null
     */
    public function getNodeHash()
    {
        return $this->container['node_hash'];
    }

    /**
     * Sets node_hash
     *
     * @param int|null $node_hash The hash identifier for the node, which unfortunately is also content version dependent but can be (and ideally, should be) used instead of the nodeIndex to uniquely identify the node.  The two exist side-by-side for backcompat reasons due to the Great Talent Node Restructuring of Destiny 1, and I ran out of time to remove one of them and standardize on the other. Sorry!
     *
     * @return self
     */
    public function setNodeHash($node_hash)
    {
        $this->container['node_hash'] = $node_hash;

        return $this;
    }

    /**
     * Gets row
     *
     * @return int|null
     */
    public function getRow()
    {
        return $this->container['row'];
    }

    /**
     * Sets row
     *
     * @param int|null $row The visual \"row\" where the node should be shown in the UI. If negative, then the node is hidden.
     *
     * @return self
     */
    public function setRow($row)
    {
        $this->container['row'] = $row;

        return $this;
    }

    /**
     * Gets column
     *
     * @return int|null
     */
    public function getColumn()
    {
        return $this->container['column'];
    }

    /**
     * Sets column
     *
     * @param int|null $column The visual \"column\" where the node should be shown in the UI. If negative, the node is hidden.
     *
     * @return self
     */
    public function setColumn($column)
    {
        $this->container['column'] = $column;

        return $this;
    }

    /**
     * Gets prerequisite_node_indexes
     *
     * @return int[]|null
     */
    public function getPrerequisiteNodeIndexes()
    {
        return $this->container['prerequisite_node_indexes'];
    }

    /**
     * Sets prerequisite_node_indexes
     *
     * @param int[]|null $prerequisite_node_indexes Indexes into the DestinyTalentGridDefinition.nodes property for any nodes that must be activated before this one is allowed to be activated.  I would have liked to change this to hashes for Destiny 2, but we have run out of time.
     *
     * @return self
     */
    public function setPrerequisiteNodeIndexes($prerequisite_node_indexes)
    {
        $this->container['prerequisite_node_indexes'] = $prerequisite_node_indexes;

        return $this;
    }

    /**
     * Gets binary_pair_node_index
     *
     * @return int|null
     */
    public function getBinaryPairNodeIndex()
    {
        return $this->container['binary_pair_node_index'];
    }

    /**
     * Sets binary_pair_node_index
     *
     * @param int|null $binary_pair_node_index At one point, Talent Nodes supported the idea of \"Binary Pairs\": nodes that overlapped each other visually, and where activating one deactivated the other. They ended up not being used, mostly because Exclusive Sets are *almost* a superset of this concept, but the potential for it to be used still exists in theory.  If this is ever used, this will be the index into the DestinyTalentGridDefinition.nodes property for the node that is the binary pair match to this node. Activating one deactivates the other.
     *
     * @return self
     */
    public function setBinaryPairNodeIndex($binary_pair_node_index)
    {
        $this->container['binary_pair_node_index'] = $binary_pair_node_index;

        return $this;
    }

    /**
     * Gets auto_unlocks
     *
     * @return bool|null
     */
    public function getAutoUnlocks()
    {
        return $this->container['auto_unlocks'];
    }

    /**
     * Sets auto_unlocks
     *
     * @param bool|null $auto_unlocks If true, this node will automatically unlock when the Talent Grid's level reaches the required level of the current step of this node.
     *
     * @return self
     */
    public function setAutoUnlocks($auto_unlocks)
    {
        $this->container['auto_unlocks'] = $auto_unlocks;

        return $this;
    }

    /**
     * Gets last_step_repeats
     *
     * @return bool|null
     */
    public function getLastStepRepeats()
    {
        return $this->container['last_step_repeats'];
    }

    /**
     * Sets last_step_repeats
     *
     * @param bool|null $last_step_repeats At one point, Nodes were going to be able to be activated multiple times, changing the current step and potentially piling on multiple effects from the previously activated steps. This property would indicate if the last step could be activated multiple times.   This is not currently used, but it isn't out of the question that this could end up being used again in a theoretical future.
     *
     * @return self
     */
    public function setLastStepRepeats($last_step_repeats)
    {
        $this->container['last_step_repeats'] = $last_step_repeats;

        return $this;
    }

    /**
     * Gets is_random
     *
     * @return bool|null
     */
    public function getIsRandom()
    {
        return $this->container['is_random'];
    }

    /**
     * Sets is_random
     *
     * @param bool|null $is_random If this is true, the node's step is determined randomly rather than the first step being chosen.
     *
     * @return self
     */
    public function setIsRandom($is_random)
    {
        $this->container['is_random'] = $is_random;

        return $this;
    }

    /**
     * Gets random_activation_requirement
     *
     * @return DestinyDefinitionsDestinyNodeActivationRequirement|null
     */
    public function getRandomActivationRequirement()
    {
        return $this->container['random_activation_requirement'];
    }

    /**
     * Sets random_activation_requirement
     *
     * @param DestinyDefinitionsDestinyNodeActivationRequirement|null $random_activation_requirement At one point, you were going to be able to repurchase talent nodes that had random steps, to \"re-roll\" the current step of the node (and thus change the properties of your item). This was to be the activation requirement for performing that re-roll.  The system still exists to do this, as far as I know, so it may yet come back around!
     *
     * @return self
     */
    public function setRandomActivationRequirement($random_activation_requirement)
    {
        $this->container['random_activation_requirement'] = $random_activation_requirement;

        return $this;
    }

    /**
     * Gets is_random_repurchasable
     *
     * @return bool|null
     */
    public function getIsRandomRepurchasable()
    {
        return $this->container['is_random_repurchasable'];
    }

    /**
     * Sets is_random_repurchasable
     *
     * @param bool|null $is_random_repurchasable If this is true, the node can be \"re-rolled\" to acquire a different random current step. This is not used, but still exists for a theoretical future of talent grids.
     *
     * @return self
     */
    public function setIsRandomRepurchasable($is_random_repurchasable)
    {
        $this->container['is_random_repurchasable'] = $is_random_repurchasable;

        return $this;
    }

    /**
     * Gets steps
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyNodeStepDefinition[]|null
     */
    public function getSteps()
    {
        return $this->container['steps'];
    }

    /**
     * Sets steps
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyNodeStepDefinition[]|null $steps At this point, \"steps\" have been obfuscated into conceptual entities, aggregating the underlying notions of \"properties\" and \"true steps\".  If you need to know a step as it truly exists - such as when recreating Node logic when processing Vendor data - you'll have to use the \"realSteps\" property below.
     *
     * @return self
     */
    public function setSteps($steps)
    {
        $this->container['steps'] = $steps;

        return $this;
    }

    /**
     * Gets exclusive_with_node_hashes
     *
     * @return int[]|null
     */
    public function getExclusiveWithNodeHashes()
    {
        return $this->container['exclusive_with_node_hashes'];
    }

    /**
     * Sets exclusive_with_node_hashes
     *
     * @param int[]|null $exclusive_with_node_hashes The nodeHash values for nodes that are in an Exclusive Set with this node.  See DestinyTalentGridDefinition.exclusiveSets for more info about exclusive sets.  Again, note that these are nodeHashes and *not* nodeIndexes.
     *
     * @return self
     */
    public function setExclusiveWithNodeHashes($exclusive_with_node_hashes)
    {
        $this->container['exclusive_with_node_hashes'] = $exclusive_with_node_hashes;

        return $this;
    }

    /**
     * Gets random_start_progression_bar_at_progression
     *
     * @return int|null
     */
    public function getRandomStartProgressionBarAtProgression()
    {
        return $this->container['random_start_progression_bar_at_progression'];
    }

    /**
     * Sets random_start_progression_bar_at_progression
     *
     * @param int|null $random_start_progression_bar_at_progression If the node's step is randomly selected, this is the amount of the Talent Grid's progression experience at which the progression bar for the node should be shown.
     *
     * @return self
     */
    public function setRandomStartProgressionBarAtProgression($random_start_progression_bar_at_progression)
    {
        $this->container['random_start_progression_bar_at_progression'] = $random_start_progression_bar_at_progression;

        return $this;
    }

    /**
     * Gets layout_identifier
     *
     * @return string|null
     */
    public function getLayoutIdentifier()
    {
        return $this->container['layout_identifier'];
    }

    /**
     * Sets layout_identifier
     *
     * @param string|null $layout_identifier A string identifier for a custom visual layout to apply to this talent node. Unfortunately, we do not have any data for rendering these custom layouts. It will be up to you to interpret these strings and change your UI if you want to have custom UI matching these layouts.
     *
     * @return self
     */
    public function setLayoutIdentifier($layout_identifier)
    {
        $this->container['layout_identifier'] = $layout_identifier;

        return $this;
    }

    /**
     * Gets group_hash
     *
     * @return int|null
     */
    public function getGroupHash()
    {
        return $this->container['group_hash'];
    }

    /**
     * Sets group_hash
     *
     * @param int|null $group_hash As of Destiny 2, nodes can exist as part of \"Exclusive Groups\". These differ from exclusive sets in that, within the group, many nodes can be activated. But the act of activating any node in the group will cause \"opposing\" nodes (nodes in groups that are not allowed to be activated at the same time as this group) to deactivate.  See DestinyTalentExclusiveGroup for more information on the details. This is an identifier for this node's group, if it is part of one.
     *
     * @return self
     */
    public function setGroupHash($group_hash)
    {
        $this->container['group_hash'] = $group_hash;

        return $this;
    }

    /**
     * Gets lore_hash
     *
     * @return int|null
     */
    public function getLoreHash()
    {
        return $this->container['lore_hash'];
    }

    /**
     * Sets lore_hash
     *
     * @param int|null $lore_hash Talent nodes can be associated with a piece of Lore, generally rendered in a tooltip. This is the hash identifier of the lore element to show, if there is one to be show.
     *
     * @return self
     */
    public function setLoreHash($lore_hash)
    {
        $this->container['lore_hash'] = $lore_hash;

        return $this;
    }

    /**
     * Gets node_style_identifier
     *
     * @return string|null
     */
    public function getNodeStyleIdentifier()
    {
        return $this->container['node_style_identifier'];
    }

    /**
     * Sets node_style_identifier
     *
     * @param string|null $node_style_identifier Comes from the talent grid node style: this identifier should be used to determine how to render the node in the UI.
     *
     * @return self
     */
    public function setNodeStyleIdentifier($node_style_identifier)
    {
        $this->container['node_style_identifier'] = $node_style_identifier;

        return $this;
    }

    /**
     * Gets ignore_for_completion
     *
     * @return bool|null
     */
    public function getIgnoreForCompletion()
    {
        return $this->container['ignore_for_completion'];
    }

    /**
     * Sets ignore_for_completion
     *
     * @param bool|null $ignore_for_completion Comes from the talent grid node style: if true, then this node should be ignored for determining whether the grid is complete.
     *
     * @return self
     */
    public function setIgnoreForCompletion($ignore_for_completion)
    {
        $this->container['ignore_for_completion'] = $ignore_for_completion;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


