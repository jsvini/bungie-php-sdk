<?php
/**
 * DestinyDefinitionsDestinyInventoryItemDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsDestinyInventoryItemDefinition Class Doc Comment
 *
 * @category Class
 * @description So much of what you see in Destiny is actually an Item used in a new and creative way. This is the definition for Items in Destiny, which started off as just entities that could exist in your Inventory but ended up being the backing data for so much more: quests, reward previews, slots, and subclasses.  In practice, you will want to associate this data with \&quot;live\&quot; item data from a Bungie.Net Platform call: these definitions describe the item in generic, non-instanced terms: but an actual instance of an item can vary widely from these generic definitions.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsDestinyInventoryItemDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.DestinyInventoryItemDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'display_properties' => '\OpenAPI\Client\Model\DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition',
        'tooltip_notifications' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyItemTooltipNotification[]',
        'collectible_hash' => 'int',
        'icon_watermark' => 'string',
        'icon_watermark_shelved' => 'string',
        'secondary_icon' => 'string',
        'secondary_overlay' => 'string',
        'secondary_special' => 'string',
        'background_color' => 'DestinyMiscDestinyColor',
        'screenshot' => 'string',
        'item_type_display_name' => 'string',
        'ui_item_display_style' => 'string',
        'item_type_and_tier_display_name' => 'string',
        'display_source' => 'string',
        'tooltip_style' => 'string',
        'action' => 'DestinyDefinitionsDestinyItemActionBlockDefinition',
        'inventory' => 'DestinyDefinitionsDestinyItemInventoryBlockDefinition',
        'set_data' => 'DestinyDefinitionsDestinyItemSetBlockDefinition',
        'stats' => 'DestinyDefinitionsDestinyItemStatBlockDefinition',
        'emblem_objective_hash' => 'int',
        'equipping_block' => 'DestinyDefinitionsDestinyEquippingBlockDefinition',
        'translation_block' => 'DestinyDefinitionsDestinyItemTranslationBlockDefinition',
        'preview' => 'DestinyDefinitionsDestinyItemPreviewBlockDefinition',
        'quality' => 'DestinyDefinitionsDestinyItemQualityBlockDefinition',
        'value' => 'DestinyDefinitionsDestinyItemValueBlockDefinition',
        'source_data' => 'DestinyDefinitionsDestinyItemSourceBlockDefinition',
        'objectives' => 'DestinyDefinitionsDestinyItemObjectiveBlockDefinition',
        'metrics' => 'DestinyDefinitionsDestinyItemMetricBlockDefinition',
        'plug' => 'DestinyDefinitionsItemsDestinyItemPlugDefinition',
        'gearset' => 'DestinyDefinitionsDestinyItemGearsetBlockDefinition',
        'sack' => 'DestinyDefinitionsDestinyItemSackBlockDefinition',
        'sockets' => 'DestinyDefinitionsDestinyItemSocketBlockDefinition',
        'summary' => 'DestinyDefinitionsDestinyItemSummaryBlockDefinition',
        'talent_grid' => 'DestinyDefinitionsDestinyItemTalentGridBlockDefinition',
        'investment_stats' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyItemInvestmentStatDefinition[]',
        'perks' => '\OpenAPI\Client\Model\DestinyDefinitionsDestinyItemPerkEntryDefinition[]',
        'lore_hash' => 'int',
        'summary_item_hash' => 'int',
        'animations' => '\OpenAPI\Client\Model\DestinyDefinitionsAnimationsDestinyAnimationReference[]',
        'allow_actions' => 'bool',
        'links' => '\OpenAPI\Client\Model\LinksHyperlinkReference[]',
        'does_postmaster_pull_have_side_effects' => 'bool',
        'non_transferrable' => 'bool',
        'item_category_hashes' => 'int[]',
        'special_item_type' => 'int',
        'item_type' => 'int',
        'item_sub_type' => 'int',
        'class_type' => 'int',
        'breaker_type' => 'int',
        'breaker_type_hash' => 'int',
        'equippable' => 'bool',
        'damage_type_hashes' => 'int[]',
        'damage_types' => 'int[]',
        'default_damage_type' => 'int',
        'default_damage_type_hash' => 'int',
        'season_hash' => 'int',
        'is_wrapper' => 'bool',
        'trait_ids' => 'string[]',
        'hash' => 'int',
        'index' => 'int',
        'redacted' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'display_properties' => null,
        'tooltip_notifications' => null,
        'collectible_hash' => 'uint32',
        'icon_watermark' => null,
        'icon_watermark_shelved' => null,
        'secondary_icon' => null,
        'secondary_overlay' => null,
        'secondary_special' => null,
        'background_color' => null,
        'screenshot' => null,
        'item_type_display_name' => null,
        'ui_item_display_style' => null,
        'item_type_and_tier_display_name' => null,
        'display_source' => null,
        'tooltip_style' => null,
        'action' => null,
        'inventory' => null,
        'set_data' => null,
        'stats' => null,
        'emblem_objective_hash' => 'uint32',
        'equipping_block' => null,
        'translation_block' => null,
        'preview' => null,
        'quality' => null,
        'value' => null,
        'source_data' => null,
        'objectives' => null,
        'metrics' => null,
        'plug' => null,
        'gearset' => null,
        'sack' => null,
        'sockets' => null,
        'summary' => null,
        'talent_grid' => null,
        'investment_stats' => null,
        'perks' => null,
        'lore_hash' => 'uint32',
        'summary_item_hash' => 'uint32',
        'animations' => null,
        'allow_actions' => null,
        'links' => null,
        'does_postmaster_pull_have_side_effects' => null,
        'non_transferrable' => null,
        'item_category_hashes' => 'uint32',
        'special_item_type' => 'int32',
        'item_type' => 'int32',
        'item_sub_type' => 'int32',
        'class_type' => 'int32',
        'breaker_type' => 'int32',
        'breaker_type_hash' => 'uint32',
        'equippable' => null,
        'damage_type_hashes' => 'uint32',
        'damage_types' => 'int32',
        'default_damage_type' => 'int32',
        'default_damage_type_hash' => 'uint32',
        'season_hash' => 'uint32',
        'is_wrapper' => null,
        'trait_ids' => null,
        'hash' => 'uint32',
        'index' => 'int32',
        'redacted' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'display_properties' => 'displayProperties',
        'tooltip_notifications' => 'tooltipNotifications',
        'collectible_hash' => 'collectibleHash',
        'icon_watermark' => 'iconWatermark',
        'icon_watermark_shelved' => 'iconWatermarkShelved',
        'secondary_icon' => 'secondaryIcon',
        'secondary_overlay' => 'secondaryOverlay',
        'secondary_special' => 'secondarySpecial',
        'background_color' => 'backgroundColor',
        'screenshot' => 'screenshot',
        'item_type_display_name' => 'itemTypeDisplayName',
        'ui_item_display_style' => 'uiItemDisplayStyle',
        'item_type_and_tier_display_name' => 'itemTypeAndTierDisplayName',
        'display_source' => 'displaySource',
        'tooltip_style' => 'tooltipStyle',
        'action' => 'action',
        'inventory' => 'inventory',
        'set_data' => 'setData',
        'stats' => 'stats',
        'emblem_objective_hash' => 'emblemObjectiveHash',
        'equipping_block' => 'equippingBlock',
        'translation_block' => 'translationBlock',
        'preview' => 'preview',
        'quality' => 'quality',
        'value' => 'value',
        'source_data' => 'sourceData',
        'objectives' => 'objectives',
        'metrics' => 'metrics',
        'plug' => 'plug',
        'gearset' => 'gearset',
        'sack' => 'sack',
        'sockets' => 'sockets',
        'summary' => 'summary',
        'talent_grid' => 'talentGrid',
        'investment_stats' => 'investmentStats',
        'perks' => 'perks',
        'lore_hash' => 'loreHash',
        'summary_item_hash' => 'summaryItemHash',
        'animations' => 'animations',
        'allow_actions' => 'allowActions',
        'links' => 'links',
        'does_postmaster_pull_have_side_effects' => 'doesPostmasterPullHaveSideEffects',
        'non_transferrable' => 'nonTransferrable',
        'item_category_hashes' => 'itemCategoryHashes',
        'special_item_type' => 'specialItemType',
        'item_type' => 'itemType',
        'item_sub_type' => 'itemSubType',
        'class_type' => 'classType',
        'breaker_type' => 'breakerType',
        'breaker_type_hash' => 'breakerTypeHash',
        'equippable' => 'equippable',
        'damage_type_hashes' => 'damageTypeHashes',
        'damage_types' => 'damageTypes',
        'default_damage_type' => 'defaultDamageType',
        'default_damage_type_hash' => 'defaultDamageTypeHash',
        'season_hash' => 'seasonHash',
        'is_wrapper' => 'isWrapper',
        'trait_ids' => 'traitIds',
        'hash' => 'hash',
        'index' => 'index',
        'redacted' => 'redacted'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'display_properties' => 'setDisplayProperties',
        'tooltip_notifications' => 'setTooltipNotifications',
        'collectible_hash' => 'setCollectibleHash',
        'icon_watermark' => 'setIconWatermark',
        'icon_watermark_shelved' => 'setIconWatermarkShelved',
        'secondary_icon' => 'setSecondaryIcon',
        'secondary_overlay' => 'setSecondaryOverlay',
        'secondary_special' => 'setSecondarySpecial',
        'background_color' => 'setBackgroundColor',
        'screenshot' => 'setScreenshot',
        'item_type_display_name' => 'setItemTypeDisplayName',
        'ui_item_display_style' => 'setUiItemDisplayStyle',
        'item_type_and_tier_display_name' => 'setItemTypeAndTierDisplayName',
        'display_source' => 'setDisplaySource',
        'tooltip_style' => 'setTooltipStyle',
        'action' => 'setAction',
        'inventory' => 'setInventory',
        'set_data' => 'setSetData',
        'stats' => 'setStats',
        'emblem_objective_hash' => 'setEmblemObjectiveHash',
        'equipping_block' => 'setEquippingBlock',
        'translation_block' => 'setTranslationBlock',
        'preview' => 'setPreview',
        'quality' => 'setQuality',
        'value' => 'setValue',
        'source_data' => 'setSourceData',
        'objectives' => 'setObjectives',
        'metrics' => 'setMetrics',
        'plug' => 'setPlug',
        'gearset' => 'setGearset',
        'sack' => 'setSack',
        'sockets' => 'setSockets',
        'summary' => 'setSummary',
        'talent_grid' => 'setTalentGrid',
        'investment_stats' => 'setInvestmentStats',
        'perks' => 'setPerks',
        'lore_hash' => 'setLoreHash',
        'summary_item_hash' => 'setSummaryItemHash',
        'animations' => 'setAnimations',
        'allow_actions' => 'setAllowActions',
        'links' => 'setLinks',
        'does_postmaster_pull_have_side_effects' => 'setDoesPostmasterPullHaveSideEffects',
        'non_transferrable' => 'setNonTransferrable',
        'item_category_hashes' => 'setItemCategoryHashes',
        'special_item_type' => 'setSpecialItemType',
        'item_type' => 'setItemType',
        'item_sub_type' => 'setItemSubType',
        'class_type' => 'setClassType',
        'breaker_type' => 'setBreakerType',
        'breaker_type_hash' => 'setBreakerTypeHash',
        'equippable' => 'setEquippable',
        'damage_type_hashes' => 'setDamageTypeHashes',
        'damage_types' => 'setDamageTypes',
        'default_damage_type' => 'setDefaultDamageType',
        'default_damage_type_hash' => 'setDefaultDamageTypeHash',
        'season_hash' => 'setSeasonHash',
        'is_wrapper' => 'setIsWrapper',
        'trait_ids' => 'setTraitIds',
        'hash' => 'setHash',
        'index' => 'setIndex',
        'redacted' => 'setRedacted'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'display_properties' => 'getDisplayProperties',
        'tooltip_notifications' => 'getTooltipNotifications',
        'collectible_hash' => 'getCollectibleHash',
        'icon_watermark' => 'getIconWatermark',
        'icon_watermark_shelved' => 'getIconWatermarkShelved',
        'secondary_icon' => 'getSecondaryIcon',
        'secondary_overlay' => 'getSecondaryOverlay',
        'secondary_special' => 'getSecondarySpecial',
        'background_color' => 'getBackgroundColor',
        'screenshot' => 'getScreenshot',
        'item_type_display_name' => 'getItemTypeDisplayName',
        'ui_item_display_style' => 'getUiItemDisplayStyle',
        'item_type_and_tier_display_name' => 'getItemTypeAndTierDisplayName',
        'display_source' => 'getDisplaySource',
        'tooltip_style' => 'getTooltipStyle',
        'action' => 'getAction',
        'inventory' => 'getInventory',
        'set_data' => 'getSetData',
        'stats' => 'getStats',
        'emblem_objective_hash' => 'getEmblemObjectiveHash',
        'equipping_block' => 'getEquippingBlock',
        'translation_block' => 'getTranslationBlock',
        'preview' => 'getPreview',
        'quality' => 'getQuality',
        'value' => 'getValue',
        'source_data' => 'getSourceData',
        'objectives' => 'getObjectives',
        'metrics' => 'getMetrics',
        'plug' => 'getPlug',
        'gearset' => 'getGearset',
        'sack' => 'getSack',
        'sockets' => 'getSockets',
        'summary' => 'getSummary',
        'talent_grid' => 'getTalentGrid',
        'investment_stats' => 'getInvestmentStats',
        'perks' => 'getPerks',
        'lore_hash' => 'getLoreHash',
        'summary_item_hash' => 'getSummaryItemHash',
        'animations' => 'getAnimations',
        'allow_actions' => 'getAllowActions',
        'links' => 'getLinks',
        'does_postmaster_pull_have_side_effects' => 'getDoesPostmasterPullHaveSideEffects',
        'non_transferrable' => 'getNonTransferrable',
        'item_category_hashes' => 'getItemCategoryHashes',
        'special_item_type' => 'getSpecialItemType',
        'item_type' => 'getItemType',
        'item_sub_type' => 'getItemSubType',
        'class_type' => 'getClassType',
        'breaker_type' => 'getBreakerType',
        'breaker_type_hash' => 'getBreakerTypeHash',
        'equippable' => 'getEquippable',
        'damage_type_hashes' => 'getDamageTypeHashes',
        'damage_types' => 'getDamageTypes',
        'default_damage_type' => 'getDefaultDamageType',
        'default_damage_type_hash' => 'getDefaultDamageTypeHash',
        'season_hash' => 'getSeasonHash',
        'is_wrapper' => 'getIsWrapper',
        'trait_ids' => 'getTraitIds',
        'hash' => 'getHash',
        'index' => 'getIndex',
        'redacted' => 'getRedacted'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['display_properties'] = $data['display_properties'] ?? null;
        $this->container['tooltip_notifications'] = $data['tooltip_notifications'] ?? null;
        $this->container['collectible_hash'] = $data['collectible_hash'] ?? null;
        $this->container['icon_watermark'] = $data['icon_watermark'] ?? null;
        $this->container['icon_watermark_shelved'] = $data['icon_watermark_shelved'] ?? null;
        $this->container['secondary_icon'] = $data['secondary_icon'] ?? null;
        $this->container['secondary_overlay'] = $data['secondary_overlay'] ?? null;
        $this->container['secondary_special'] = $data['secondary_special'] ?? null;
        $this->container['background_color'] = $data['background_color'] ?? null;
        $this->container['screenshot'] = $data['screenshot'] ?? null;
        $this->container['item_type_display_name'] = $data['item_type_display_name'] ?? null;
        $this->container['ui_item_display_style'] = $data['ui_item_display_style'] ?? null;
        $this->container['item_type_and_tier_display_name'] = $data['item_type_and_tier_display_name'] ?? null;
        $this->container['display_source'] = $data['display_source'] ?? null;
        $this->container['tooltip_style'] = $data['tooltip_style'] ?? null;
        $this->container['action'] = $data['action'] ?? null;
        $this->container['inventory'] = $data['inventory'] ?? null;
        $this->container['set_data'] = $data['set_data'] ?? null;
        $this->container['stats'] = $data['stats'] ?? null;
        $this->container['emblem_objective_hash'] = $data['emblem_objective_hash'] ?? null;
        $this->container['equipping_block'] = $data['equipping_block'] ?? null;
        $this->container['translation_block'] = $data['translation_block'] ?? null;
        $this->container['preview'] = $data['preview'] ?? null;
        $this->container['quality'] = $data['quality'] ?? null;
        $this->container['value'] = $data['value'] ?? null;
        $this->container['source_data'] = $data['source_data'] ?? null;
        $this->container['objectives'] = $data['objectives'] ?? null;
        $this->container['metrics'] = $data['metrics'] ?? null;
        $this->container['plug'] = $data['plug'] ?? null;
        $this->container['gearset'] = $data['gearset'] ?? null;
        $this->container['sack'] = $data['sack'] ?? null;
        $this->container['sockets'] = $data['sockets'] ?? null;
        $this->container['summary'] = $data['summary'] ?? null;
        $this->container['talent_grid'] = $data['talent_grid'] ?? null;
        $this->container['investment_stats'] = $data['investment_stats'] ?? null;
        $this->container['perks'] = $data['perks'] ?? null;
        $this->container['lore_hash'] = $data['lore_hash'] ?? null;
        $this->container['summary_item_hash'] = $data['summary_item_hash'] ?? null;
        $this->container['animations'] = $data['animations'] ?? null;
        $this->container['allow_actions'] = $data['allow_actions'] ?? null;
        $this->container['links'] = $data['links'] ?? null;
        $this->container['does_postmaster_pull_have_side_effects'] = $data['does_postmaster_pull_have_side_effects'] ?? null;
        $this->container['non_transferrable'] = $data['non_transferrable'] ?? null;
        $this->container['item_category_hashes'] = $data['item_category_hashes'] ?? null;
        $this->container['special_item_type'] = $data['special_item_type'] ?? null;
        $this->container['item_type'] = $data['item_type'] ?? null;
        $this->container['item_sub_type'] = $data['item_sub_type'] ?? null;
        $this->container['class_type'] = $data['class_type'] ?? null;
        $this->container['breaker_type'] = $data['breaker_type'] ?? null;
        $this->container['breaker_type_hash'] = $data['breaker_type_hash'] ?? null;
        $this->container['equippable'] = $data['equippable'] ?? null;
        $this->container['damage_type_hashes'] = $data['damage_type_hashes'] ?? null;
        $this->container['damage_types'] = $data['damage_types'] ?? null;
        $this->container['default_damage_type'] = $data['default_damage_type'] ?? null;
        $this->container['default_damage_type_hash'] = $data['default_damage_type_hash'] ?? null;
        $this->container['season_hash'] = $data['season_hash'] ?? null;
        $this->container['is_wrapper'] = $data['is_wrapper'] ?? null;
        $this->container['trait_ids'] = $data['trait_ids'] ?? null;
        $this->container['hash'] = $data['hash'] ?? null;
        $this->container['index'] = $data['index'] ?? null;
        $this->container['redacted'] = $data['redacted'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets display_properties
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null
     */
    public function getDisplayProperties()
    {
        return $this->container['display_properties'];
    }

    /**
     * Sets display_properties
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition|null $display_properties display_properties
     *
     * @return self
     */
    public function setDisplayProperties($display_properties)
    {
        $this->container['display_properties'] = $display_properties;

        return $this;
    }

    /**
     * Gets tooltip_notifications
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyItemTooltipNotification[]|null
     */
    public function getTooltipNotifications()
    {
        return $this->container['tooltip_notifications'];
    }

    /**
     * Sets tooltip_notifications
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyItemTooltipNotification[]|null $tooltip_notifications Tooltips that only come up conditionally for the item. Check the live data DestinyItemComponent.tooltipNotificationIndexes property for which of these should be shown at runtime.
     *
     * @return self
     */
    public function setTooltipNotifications($tooltip_notifications)
    {
        $this->container['tooltip_notifications'] = $tooltip_notifications;

        return $this;
    }

    /**
     * Gets collectible_hash
     *
     * @return int|null
     */
    public function getCollectibleHash()
    {
        return $this->container['collectible_hash'];
    }

    /**
     * Sets collectible_hash
     *
     * @param int|null $collectible_hash If this item has a collectible related to it, this is the hash identifier of that collectible entry.
     *
     * @return self
     */
    public function setCollectibleHash($collectible_hash)
    {
        $this->container['collectible_hash'] = $collectible_hash;

        return $this;
    }

    /**
     * Gets icon_watermark
     *
     * @return string|null
     */
    public function getIconWatermark()
    {
        return $this->container['icon_watermark'];
    }

    /**
     * Sets icon_watermark
     *
     * @param string|null $icon_watermark If available, this is the original 'active' release watermark overlay for the icon. If the item has different versions, this can be overridden by the 'display version watermark icon' from the 'quality' block. Alternatively, if there is no watermark for the version, and the item version has a power cap below the current season power cap, this can be overridden by the iconWatermarkShelved property.
     *
     * @return self
     */
    public function setIconWatermark($icon_watermark)
    {
        $this->container['icon_watermark'] = $icon_watermark;

        return $this;
    }

    /**
     * Gets icon_watermark_shelved
     *
     * @return string|null
     */
    public function getIconWatermarkShelved()
    {
        return $this->container['icon_watermark_shelved'];
    }

    /**
     * Sets icon_watermark_shelved
     *
     * @param string|null $icon_watermark_shelved If available, this is the 'shelved' release watermark overlay for the icon. If the item version has a power cap below the current season power cap, it can be treated as 'shelved', and should be shown with this 'shelved' watermark overlay.
     *
     * @return self
     */
    public function setIconWatermarkShelved($icon_watermark_shelved)
    {
        $this->container['icon_watermark_shelved'] = $icon_watermark_shelved;

        return $this;
    }

    /**
     * Gets secondary_icon
     *
     * @return string|null
     */
    public function getSecondaryIcon()
    {
        return $this->container['secondary_icon'];
    }

    /**
     * Sets secondary_icon
     *
     * @param string|null $secondary_icon A secondary icon associated with the item. Currently this is used in very context specific applications, such as Emblem Nameplates.
     *
     * @return self
     */
    public function setSecondaryIcon($secondary_icon)
    {
        $this->container['secondary_icon'] = $secondary_icon;

        return $this;
    }

    /**
     * Gets secondary_overlay
     *
     * @return string|null
     */
    public function getSecondaryOverlay()
    {
        return $this->container['secondary_overlay'];
    }

    /**
     * Sets secondary_overlay
     *
     * @param string|null $secondary_overlay Pulled from the secondary icon, this is the \"secondary background\" of the secondary icon. Confusing? Sure, that's why I call it \"overlay\" here: because as far as it's been used thus far, it has been for an optional overlay image. We'll see if that holds up, but at least for now it explains what this image is a bit better.
     *
     * @return self
     */
    public function setSecondaryOverlay($secondary_overlay)
    {
        $this->container['secondary_overlay'] = $secondary_overlay;

        return $this;
    }

    /**
     * Gets secondary_special
     *
     * @return string|null
     */
    public function getSecondarySpecial()
    {
        return $this->container['secondary_special'];
    }

    /**
     * Sets secondary_special
     *
     * @param string|null $secondary_special Pulled from the Secondary Icon, this is the \"special\" background for the item. For Emblems, this is the background image used on the Details view: but it need not be limited to that for other types of items.
     *
     * @return self
     */
    public function setSecondarySpecial($secondary_special)
    {
        $this->container['secondary_special'] = $secondary_special;

        return $this;
    }

    /**
     * Gets background_color
     *
     * @return DestinyMiscDestinyColor|null
     */
    public function getBackgroundColor()
    {
        return $this->container['background_color'];
    }

    /**
     * Sets background_color
     *
     * @param DestinyMiscDestinyColor|null $background_color Sometimes, an item will have a background color. Most notably this occurs with Emblems, who use the Background Color for small character nameplates such as the \"friends\" view you see in-game. There are almost certainly other items that have background color as well, though I have not bothered to investigate what items have it nor what purposes they serve: use it as you will.
     *
     * @return self
     */
    public function setBackgroundColor($background_color)
    {
        $this->container['background_color'] = $background_color;

        return $this;
    }

    /**
     * Gets screenshot
     *
     * @return string|null
     */
    public function getScreenshot()
    {
        return $this->container['screenshot'];
    }

    /**
     * Sets screenshot
     *
     * @param string|null $screenshot If we were able to acquire an in-game screenshot for the item, the path to that screenshot will be returned here. Note that not all items have screenshots: particularly not any non-equippable items.
     *
     * @return self
     */
    public function setScreenshot($screenshot)
    {
        $this->container['screenshot'] = $screenshot;

        return $this;
    }

    /**
     * Gets item_type_display_name
     *
     * @return string|null
     */
    public function getItemTypeDisplayName()
    {
        return $this->container['item_type_display_name'];
    }

    /**
     * Sets item_type_display_name
     *
     * @param string|null $item_type_display_name The localized title/name of the item's type. This can be whatever the designers want, and has no guarantee of consistency between items.
     *
     * @return self
     */
    public function setItemTypeDisplayName($item_type_display_name)
    {
        $this->container['item_type_display_name'] = $item_type_display_name;

        return $this;
    }

    /**
     * Gets ui_item_display_style
     *
     * @return string|null
     */
    public function getUiItemDisplayStyle()
    {
        return $this->container['ui_item_display_style'];
    }

    /**
     * Sets ui_item_display_style
     *
     * @param string|null $ui_item_display_style A string identifier that the game's UI uses to determine how the item should be rendered in inventory screens and the like. This could really be anything - at the moment, we don't have the time to really breakdown and maintain all the possible strings this could be, partly because new ones could be added ad hoc. But if you want to use it to dictate your own UI, or look for items with a certain display style, go for it!
     *
     * @return self
     */
    public function setUiItemDisplayStyle($ui_item_display_style)
    {
        $this->container['ui_item_display_style'] = $ui_item_display_style;

        return $this;
    }

    /**
     * Gets item_type_and_tier_display_name
     *
     * @return string|null
     */
    public function getItemTypeAndTierDisplayName()
    {
        return $this->container['item_type_and_tier_display_name'];
    }

    /**
     * Sets item_type_and_tier_display_name
     *
     * @param string|null $item_type_and_tier_display_name It became a common enough pattern in our UI to show Item Type and Tier combined into a single localized string that I'm just going to go ahead and start pre-creating these for items.
     *
     * @return self
     */
    public function setItemTypeAndTierDisplayName($item_type_and_tier_display_name)
    {
        $this->container['item_type_and_tier_display_name'] = $item_type_and_tier_display_name;

        return $this;
    }

    /**
     * Gets display_source
     *
     * @return string|null
     */
    public function getDisplaySource()
    {
        return $this->container['display_source'];
    }

    /**
     * Sets display_source
     *
     * @param string|null $display_source In theory, it is a localized string telling you about how you can find the item. I really wish this was more consistent. Many times, it has nothing. Sometimes, it's instead a more narrative-forward description of the item. Which is cool, and I wish all properties had that data, but it should really be its own property.
     *
     * @return self
     */
    public function setDisplaySource($display_source)
    {
        $this->container['display_source'] = $display_source;

        return $this;
    }

    /**
     * Gets tooltip_style
     *
     * @return string|null
     */
    public function getTooltipStyle()
    {
        return $this->container['tooltip_style'];
    }

    /**
     * Sets tooltip_style
     *
     * @param string|null $tooltip_style An identifier that the game UI uses to determine what type of tooltip to show for the item. These have no corresponding definitions that BNet can link to: so it'll be up to you to interpret and display your UI differently according to these styles (or ignore it).
     *
     * @return self
     */
    public function setTooltipStyle($tooltip_style)
    {
        $this->container['tooltip_style'] = $tooltip_style;

        return $this;
    }

    /**
     * Gets action
     *
     * @return DestinyDefinitionsDestinyItemActionBlockDefinition|null
     */
    public function getAction()
    {
        return $this->container['action'];
    }

    /**
     * Sets action
     *
     * @param DestinyDefinitionsDestinyItemActionBlockDefinition|null $action If the item can be \"used\", this block will be non-null, and will have data related to the action performed when using the item. (Guess what? 99% of the time, this action is \"dismantle\". Shocker)
     *
     * @return self
     */
    public function setAction($action)
    {
        $this->container['action'] = $action;

        return $this;
    }

    /**
     * Gets inventory
     *
     * @return DestinyDefinitionsDestinyItemInventoryBlockDefinition|null
     */
    public function getInventory()
    {
        return $this->container['inventory'];
    }

    /**
     * Sets inventory
     *
     * @param DestinyDefinitionsDestinyItemInventoryBlockDefinition|null $inventory If this item can exist in an inventory, this block will be non-null. In practice, every item that currently exists has one of these blocks. But note that it is not necessarily guaranteed.
     *
     * @return self
     */
    public function setInventory($inventory)
    {
        $this->container['inventory'] = $inventory;

        return $this;
    }

    /**
     * Gets set_data
     *
     * @return DestinyDefinitionsDestinyItemSetBlockDefinition|null
     */
    public function getSetData()
    {
        return $this->container['set_data'];
    }

    /**
     * Sets set_data
     *
     * @param DestinyDefinitionsDestinyItemSetBlockDefinition|null $set_data If this item is a quest, this block will be non-null. In practice, I wish I had called this the Quest block, but at the time it wasn't clear to me whether it would end up being used for purposes other than quests. It will contain data about the steps in the quest, and mechanics we can use for displaying and tracking the quest.
     *
     * @return self
     */
    public function setSetData($set_data)
    {
        $this->container['set_data'] = $set_data;

        return $this;
    }

    /**
     * Gets stats
     *
     * @return DestinyDefinitionsDestinyItemStatBlockDefinition|null
     */
    public function getStats()
    {
        return $this->container['stats'];
    }

    /**
     * Sets stats
     *
     * @param DestinyDefinitionsDestinyItemStatBlockDefinition|null $stats If this item can have stats (such as a weapon, armor, or vehicle), this block will be non-null and populated with the stats found on the item.
     *
     * @return self
     */
    public function setStats($stats)
    {
        $this->container['stats'] = $stats;

        return $this;
    }

    /**
     * Gets emblem_objective_hash
     *
     * @return int|null
     */
    public function getEmblemObjectiveHash()
    {
        return $this->container['emblem_objective_hash'];
    }

    /**
     * Sets emblem_objective_hash
     *
     * @param int|null $emblem_objective_hash If the item is an emblem that has a special Objective attached to it - for instance, if the emblem tracks PVP Kills, or what-have-you. This is a bit different from, for example, the Vanguard Kill Tracker mod, which pipes data into the \"art channel\". When I get some time, I would like to standardize these so you can get at the values they expose without having to care about what they're being used for and how they are wired up, but for now here's the raw data.
     *
     * @return self
     */
    public function setEmblemObjectiveHash($emblem_objective_hash)
    {
        $this->container['emblem_objective_hash'] = $emblem_objective_hash;

        return $this;
    }

    /**
     * Gets equipping_block
     *
     * @return DestinyDefinitionsDestinyEquippingBlockDefinition|null
     */
    public function getEquippingBlock()
    {
        return $this->container['equipping_block'];
    }

    /**
     * Sets equipping_block
     *
     * @param DestinyDefinitionsDestinyEquippingBlockDefinition|null $equipping_block If this item can be equipped, this block will be non-null and will be populated with the conditions under which it can be equipped.
     *
     * @return self
     */
    public function setEquippingBlock($equipping_block)
    {
        $this->container['equipping_block'] = $equipping_block;

        return $this;
    }

    /**
     * Gets translation_block
     *
     * @return DestinyDefinitionsDestinyItemTranslationBlockDefinition|null
     */
    public function getTranslationBlock()
    {
        return $this->container['translation_block'];
    }

    /**
     * Sets translation_block
     *
     * @param DestinyDefinitionsDestinyItemTranslationBlockDefinition|null $translation_block If this item can be rendered, this block will be non-null and will be populated with rendering information.
     *
     * @return self
     */
    public function setTranslationBlock($translation_block)
    {
        $this->container['translation_block'] = $translation_block;

        return $this;
    }

    /**
     * Gets preview
     *
     * @return DestinyDefinitionsDestinyItemPreviewBlockDefinition|null
     */
    public function getPreview()
    {
        return $this->container['preview'];
    }

    /**
     * Sets preview
     *
     * @param DestinyDefinitionsDestinyItemPreviewBlockDefinition|null $preview If this item can be Used or Acquired to gain other items (for instance, how Eververse Boxes can be consumed to get items from the box), this block will be non-null and will give summary information for the items that can be acquired.
     *
     * @return self
     */
    public function setPreview($preview)
    {
        $this->container['preview'] = $preview;

        return $this;
    }

    /**
     * Gets quality
     *
     * @return DestinyDefinitionsDestinyItemQualityBlockDefinition|null
     */
    public function getQuality()
    {
        return $this->container['quality'];
    }

    /**
     * Sets quality
     *
     * @param DestinyDefinitionsDestinyItemQualityBlockDefinition|null $quality If this item can have a level or stats, this block will be non-null and will be populated with default quality (item level, \"quality\", and infusion) data. See the block for more details, there's often less upfront information in D2 so you'll want to be aware of how you use quality and item level on the definition level now.
     *
     * @return self
     */
    public function setQuality($quality)
    {
        $this->container['quality'] = $quality;

        return $this;
    }

    /**
     * Gets value
     *
     * @return DestinyDefinitionsDestinyItemValueBlockDefinition|null
     */
    public function getValue()
    {
        return $this->container['value'];
    }

    /**
     * Sets value
     *
     * @param DestinyDefinitionsDestinyItemValueBlockDefinition|null $value The conceptual \"Value\" of an item, if any was defined. See the DestinyItemValueBlockDefinition for more details.
     *
     * @return self
     */
    public function setValue($value)
    {
        $this->container['value'] = $value;

        return $this;
    }

    /**
     * Gets source_data
     *
     * @return DestinyDefinitionsDestinyItemSourceBlockDefinition|null
     */
    public function getSourceData()
    {
        return $this->container['source_data'];
    }

    /**
     * Sets source_data
     *
     * @param DestinyDefinitionsDestinyItemSourceBlockDefinition|null $source_data If this item has a known source, this block will be non-null and populated with source information. Unfortunately, at this time we are not generating sources: that is some aggressively manual work which we didn't have time for, and I'm hoping to get back to at some point in the future.
     *
     * @return self
     */
    public function setSourceData($source_data)
    {
        $this->container['source_data'] = $source_data;

        return $this;
    }

    /**
     * Gets objectives
     *
     * @return DestinyDefinitionsDestinyItemObjectiveBlockDefinition|null
     */
    public function getObjectives()
    {
        return $this->container['objectives'];
    }

    /**
     * Sets objectives
     *
     * @param DestinyDefinitionsDestinyItemObjectiveBlockDefinition|null $objectives If this item has Objectives (extra tasks that can be accomplished related to the item... most frequently when the item is a Quest Step and the Objectives need to be completed to move on to the next Quest Step), this block will be non-null and the objectives defined herein.
     *
     * @return self
     */
    public function setObjectives($objectives)
    {
        $this->container['objectives'] = $objectives;

        return $this;
    }

    /**
     * Gets metrics
     *
     * @return DestinyDefinitionsDestinyItemMetricBlockDefinition|null
     */
    public function getMetrics()
    {
        return $this->container['metrics'];
    }

    /**
     * Sets metrics
     *
     * @param DestinyDefinitionsDestinyItemMetricBlockDefinition|null $metrics If this item has available metrics to be shown, this block will be non-null have the appropriate hashes defined.
     *
     * @return self
     */
    public function setMetrics($metrics)
    {
        $this->container['metrics'] = $metrics;

        return $this;
    }

    /**
     * Gets plug
     *
     * @return DestinyDefinitionsItemsDestinyItemPlugDefinition|null
     */
    public function getPlug()
    {
        return $this->container['plug'];
    }

    /**
     * Sets plug
     *
     * @param DestinyDefinitionsItemsDestinyItemPlugDefinition|null $plug If this item *is* a Plug, this will be non-null and the info defined herein. See DestinyItemPlugDefinition for more information.
     *
     * @return self
     */
    public function setPlug($plug)
    {
        $this->container['plug'] = $plug;

        return $this;
    }

    /**
     * Gets gearset
     *
     * @return DestinyDefinitionsDestinyItemGearsetBlockDefinition|null
     */
    public function getGearset()
    {
        return $this->container['gearset'];
    }

    /**
     * Sets gearset
     *
     * @param DestinyDefinitionsDestinyItemGearsetBlockDefinition|null $gearset If this item has related items in a \"Gear Set\", this will be non-null and the relationships defined herein.
     *
     * @return self
     */
    public function setGearset($gearset)
    {
        $this->container['gearset'] = $gearset;

        return $this;
    }

    /**
     * Gets sack
     *
     * @return DestinyDefinitionsDestinyItemSackBlockDefinition|null
     */
    public function getSack()
    {
        return $this->container['sack'];
    }

    /**
     * Sets sack
     *
     * @param DestinyDefinitionsDestinyItemSackBlockDefinition|null $sack If this item is a \"reward sack\" that can be opened to provide other items, this will be non-null and the properties of the sack contained herein.
     *
     * @return self
     */
    public function setSack($sack)
    {
        $this->container['sack'] = $sack;

        return $this;
    }

    /**
     * Gets sockets
     *
     * @return DestinyDefinitionsDestinyItemSocketBlockDefinition|null
     */
    public function getSockets()
    {
        return $this->container['sockets'];
    }

    /**
     * Sets sockets
     *
     * @param DestinyDefinitionsDestinyItemSocketBlockDefinition|null $sockets If this item has any Sockets, this will be non-null and the individual sockets on the item will be defined herein.
     *
     * @return self
     */
    public function setSockets($sockets)
    {
        $this->container['sockets'] = $sockets;

        return $this;
    }

    /**
     * Gets summary
     *
     * @return DestinyDefinitionsDestinyItemSummaryBlockDefinition|null
     */
    public function getSummary()
    {
        return $this->container['summary'];
    }

    /**
     * Sets summary
     *
     * @param DestinyDefinitionsDestinyItemSummaryBlockDefinition|null $summary Summary data about the item.
     *
     * @return self
     */
    public function setSummary($summary)
    {
        $this->container['summary'] = $summary;

        return $this;
    }

    /**
     * Gets talent_grid
     *
     * @return DestinyDefinitionsDestinyItemTalentGridBlockDefinition|null
     */
    public function getTalentGrid()
    {
        return $this->container['talent_grid'];
    }

    /**
     * Sets talent_grid
     *
     * @param DestinyDefinitionsDestinyItemTalentGridBlockDefinition|null $talent_grid If the item has a Talent Grid, this will be non-null and the properties of the grid defined herein. Note that, while many items still have talent grids, the only ones with meaningful Nodes still on them will be Subclass/\"Build\" items.
     *
     * @return self
     */
    public function setTalentGrid($talent_grid)
    {
        $this->container['talent_grid'] = $talent_grid;

        return $this;
    }

    /**
     * Gets investment_stats
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyItemInvestmentStatDefinition[]|null
     */
    public function getInvestmentStats()
    {
        return $this->container['investment_stats'];
    }

    /**
     * Sets investment_stats
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyItemInvestmentStatDefinition[]|null $investment_stats If the item has stats, this block will be defined. It has the \"raw\" investment stats for the item. These investment stats don't take into account the ways that the items can spawn, nor do they take into account any Stat Group transformations. I have retained them for debugging purposes, but I do not know how useful people will find them.
     *
     * @return self
     */
    public function setInvestmentStats($investment_stats)
    {
        $this->container['investment_stats'] = $investment_stats;

        return $this;
    }

    /**
     * Gets perks
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsDestinyItemPerkEntryDefinition[]|null
     */
    public function getPerks()
    {
        return $this->container['perks'];
    }

    /**
     * Sets perks
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsDestinyItemPerkEntryDefinition[]|null $perks If the item has any *intrinsic* Perks (Perks that it will provide regardless of Sockets, Talent Grid, and other transitory state), they will be defined here.
     *
     * @return self
     */
    public function setPerks($perks)
    {
        $this->container['perks'] = $perks;

        return $this;
    }

    /**
     * Gets lore_hash
     *
     * @return int|null
     */
    public function getLoreHash()
    {
        return $this->container['lore_hash'];
    }

    /**
     * Sets lore_hash
     *
     * @param int|null $lore_hash If the item has any related Lore (DestinyLoreDefinition), this will be the hash identifier you can use to look up the lore definition.
     *
     * @return self
     */
    public function setLoreHash($lore_hash)
    {
        $this->container['lore_hash'] = $lore_hash;

        return $this;
    }

    /**
     * Gets summary_item_hash
     *
     * @return int|null
     */
    public function getSummaryItemHash()
    {
        return $this->container['summary_item_hash'];
    }

    /**
     * Sets summary_item_hash
     *
     * @param int|null $summary_item_hash There are times when the game will show you a \"summary/vague\" version of an item - such as a description of its type represented as a DestinyInventoryItemDefinition - rather than display the item itself.  This happens sometimes when summarizing possible rewards in a tooltip. This is the item displayed instead, if it exists.
     *
     * @return self
     */
    public function setSummaryItemHash($summary_item_hash)
    {
        $this->container['summary_item_hash'] = $summary_item_hash;

        return $this;
    }

    /**
     * Gets animations
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsAnimationsDestinyAnimationReference[]|null
     */
    public function getAnimations()
    {
        return $this->container['animations'];
    }

    /**
     * Sets animations
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsAnimationsDestinyAnimationReference[]|null $animations If any animations were extracted from game content for this item, these will be the definitions of those animations.
     *
     * @return self
     */
    public function setAnimations($animations)
    {
        $this->container['animations'] = $animations;

        return $this;
    }

    /**
     * Gets allow_actions
     *
     * @return bool|null
     */
    public function getAllowActions()
    {
        return $this->container['allow_actions'];
    }

    /**
     * Sets allow_actions
     *
     * @param bool|null $allow_actions BNet may forbid the execution of actions on this item via the API. If that is occurring, allowActions will be set to false.
     *
     * @return self
     */
    public function setAllowActions($allow_actions)
    {
        $this->container['allow_actions'] = $allow_actions;

        return $this;
    }

    /**
     * Gets links
     *
     * @return \OpenAPI\Client\Model\LinksHyperlinkReference[]|null
     */
    public function getLinks()
    {
        return $this->container['links'];
    }

    /**
     * Sets links
     *
     * @param \OpenAPI\Client\Model\LinksHyperlinkReference[]|null $links If we added any help or informational URLs about this item, these will be those links.
     *
     * @return self
     */
    public function setLinks($links)
    {
        $this->container['links'] = $links;

        return $this;
    }

    /**
     * Gets does_postmaster_pull_have_side_effects
     *
     * @return bool|null
     */
    public function getDoesPostmasterPullHaveSideEffects()
    {
        return $this->container['does_postmaster_pull_have_side_effects'];
    }

    /**
     * Sets does_postmaster_pull_have_side_effects
     *
     * @param bool|null $does_postmaster_pull_have_side_effects The boolean will indicate to us (and you!) whether something *could* happen when you transfer this item from the Postmaster that might be considered a \"destructive\" action.  It is not feasible currently to tell you (or ourelves!) in a consistent way whether this *will* actually cause a destructive action, so we are playing it safe: if it has the potential to do so, we will not allow it to be transferred from the Postmaster by default. You will need to check for this flag before transferring an item from the Postmaster, or else you'll end up receiving an error.
     *
     * @return self
     */
    public function setDoesPostmasterPullHaveSideEffects($does_postmaster_pull_have_side_effects)
    {
        $this->container['does_postmaster_pull_have_side_effects'] = $does_postmaster_pull_have_side_effects;

        return $this;
    }

    /**
     * Gets non_transferrable
     *
     * @return bool|null
     */
    public function getNonTransferrable()
    {
        return $this->container['non_transferrable'];
    }

    /**
     * Sets non_transferrable
     *
     * @param bool|null $non_transferrable The intrinsic transferability of an item.  I hate that this boolean is negative - but there's a reason.  Just because an item is intrinsically transferrable doesn't mean that it can be transferred, and we don't want to imply that this is the only source of that transferability.
     *
     * @return self
     */
    public function setNonTransferrable($non_transferrable)
    {
        $this->container['non_transferrable'] = $non_transferrable;

        return $this;
    }

    /**
     * Gets item_category_hashes
     *
     * @return int[]|null
     */
    public function getItemCategoryHashes()
    {
        return $this->container['item_category_hashes'];
    }

    /**
     * Sets item_category_hashes
     *
     * @param int[]|null $item_category_hashes BNet attempts to make a more formal definition of item \"Categories\", as defined by DestinyItemCategoryDefinition. This is a list of all Categories that we were able to algorithmically determine that this item is a member of. (for instance, that it's a \"Weapon\", that it's an \"Auto Rifle\", etc...)  The algorithm for these is, unfortunately, volatile. If you believe you see a miscategorized item, please let us know on the Bungie API forums.
     *
     * @return self
     */
    public function setItemCategoryHashes($item_category_hashes)
    {
        $this->container['item_category_hashes'] = $item_category_hashes;

        return $this;
    }

    /**
     * Gets special_item_type
     *
     * @return int|null
     */
    public function getSpecialItemType()
    {
        return $this->container['special_item_type'];
    }

    /**
     * Sets special_item_type
     *
     * @param int|null $special_item_type In Destiny 1, we identified some items as having particular categories that we'd like to know about for various internal logic purposes. These are defined in SpecialItemType, and while these days the itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
     *
     * @return self
     */
    public function setSpecialItemType($special_item_type)
    {
        $this->container['special_item_type'] = $special_item_type;

        return $this;
    }

    /**
     * Gets item_type
     *
     * @return int|null
     */
    public function getItemType()
    {
        return $this->container['item_type'];
    }

    /**
     * Sets item_type
     *
     * @param int|null $item_type A value indicating the \"base\" the of the item. This enum is a useful but dramatic oversimplification of what it means for an item to have a \"Type\". Still, it's handy in many situations.  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
     *
     * @return self
     */
    public function setItemType($item_type)
    {
        $this->container['item_type'] = $item_type;

        return $this;
    }

    /**
     * Gets item_sub_type
     *
     * @return int|null
     */
    public function getItemSubType()
    {
        return $this->container['item_sub_type'];
    }

    /**
     * Sets item_sub_type
     *
     * @param int|null $item_sub_type A value indicating the \"sub-type\" of the item. For instance, where an item might have an itemType value \"Weapon\", this will be something more specific like \"Auto Rifle\".  itemCategoryHashes are the preferred way of identifying types, we have retained this enum for its convenience.
     *
     * @return self
     */
    public function setItemSubType($item_sub_type)
    {
        $this->container['item_sub_type'] = $item_sub_type;

        return $this;
    }

    /**
     * Gets class_type
     *
     * @return int|null
     */
    public function getClassType()
    {
        return $this->container['class_type'];
    }

    /**
     * Sets class_type
     *
     * @param int|null $class_type We run a similarly weak-sauce algorithm to try and determine whether an item is restricted to a specific class. If we find it to be restricted in such a way, we set this classType property to match the class' enumeration value so that users can easily identify class restricted items.  If you see a mis-classed item, please inform the developers in the Bungie API forum.
     *
     * @return self
     */
    public function setClassType($class_type)
    {
        $this->container['class_type'] = $class_type;

        return $this;
    }

    /**
     * Gets breaker_type
     *
     * @return int|null
     */
    public function getBreakerType()
    {
        return $this->container['breaker_type'];
    }

    /**
     * Sets breaker_type
     *
     * @param int|null $breaker_type Some weapons and plugs can have a \"Breaker Type\": a special ability that works sort of like damage type vulnerabilities. This is (almost?) always set on items by plugs.
     *
     * @return self
     */
    public function setBreakerType($breaker_type)
    {
        $this->container['breaker_type'] = $breaker_type;

        return $this;
    }

    /**
     * Gets breaker_type_hash
     *
     * @return int|null
     */
    public function getBreakerTypeHash()
    {
        return $this->container['breaker_type_hash'];
    }

    /**
     * Sets breaker_type_hash
     *
     * @param int|null $breaker_type_hash Since we also have a breaker type definition, this is the hash for that breaker type for your convenience. Whether you use the enum or hash and look up the definition depends on what's cleanest for your code.
     *
     * @return self
     */
    public function setBreakerTypeHash($breaker_type_hash)
    {
        $this->container['breaker_type_hash'] = $breaker_type_hash;

        return $this;
    }

    /**
     * Gets equippable
     *
     * @return bool|null
     */
    public function getEquippable()
    {
        return $this->container['equippable'];
    }

    /**
     * Sets equippable
     *
     * @param bool|null $equippable If true, then you will be allowed to equip the item if you pass its other requirements.  This being false means that you cannot equip the item under any circumstances.
     *
     * @return self
     */
    public function setEquippable($equippable)
    {
        $this->container['equippable'] = $equippable;

        return $this;
    }

    /**
     * Gets damage_type_hashes
     *
     * @return int[]|null
     */
    public function getDamageTypeHashes()
    {
        return $this->container['damage_type_hashes'];
    }

    /**
     * Sets damage_type_hashes
     *
     * @param int[]|null $damage_type_hashes Theoretically, an item can have many possible damage types. In *practice*, this is not true, but just in case weapons start being made that have multiple (for instance, an item where a socket has reusable plugs for every possible damage type that you can choose from freely), this field will return all of the possible damage types that are available to the weapon by default.
     *
     * @return self
     */
    public function setDamageTypeHashes($damage_type_hashes)
    {
        $this->container['damage_type_hashes'] = $damage_type_hashes;

        return $this;
    }

    /**
     * Gets damage_types
     *
     * @return int[]|null
     */
    public function getDamageTypes()
    {
        return $this->container['damage_types'];
    }

    /**
     * Sets damage_types
     *
     * @param int[]|null $damage_types This is the list of all damage types that we know ahead of time the item can take on. Unfortunately, this does not preclude the possibility of something funky happening to give the item a damage type that cannot be predicted beforehand: for example, if some designer decides to create arbitrary non-reusable plugs that cause damage type to change.  This damage type prediction will only use the following to determine potential damage types:  - Intrinsic perks  - Talent Node perks  - Known, reusable plugs for sockets
     *
     * @return self
     */
    public function setDamageTypes($damage_types)
    {
        $this->container['damage_types'] = $damage_types;

        return $this;
    }

    /**
     * Gets default_damage_type
     *
     * @return int|null
     */
    public function getDefaultDamageType()
    {
        return $this->container['default_damage_type'];
    }

    /**
     * Sets default_damage_type
     *
     * @param int|null $default_damage_type If the item has a damage type that could be considered to be default, it will be populated here.  For various upsetting reasons, it's surprisingly cumbersome to figure this out. I hope you're happy.
     *
     * @return self
     */
    public function setDefaultDamageType($default_damage_type)
    {
        $this->container['default_damage_type'] = $default_damage_type;

        return $this;
    }

    /**
     * Gets default_damage_type_hash
     *
     * @return int|null
     */
    public function getDefaultDamageTypeHash()
    {
        return $this->container['default_damage_type_hash'];
    }

    /**
     * Sets default_damage_type_hash
     *
     * @param int|null $default_damage_type_hash Similar to defaultDamageType, but represented as the hash identifier for a DestinyDamageTypeDefinition.  I will likely regret leaving in the enumeration versions of these properties, but for now they're very convenient.
     *
     * @return self
     */
    public function setDefaultDamageTypeHash($default_damage_type_hash)
    {
        $this->container['default_damage_type_hash'] = $default_damage_type_hash;

        return $this;
    }

    /**
     * Gets season_hash
     *
     * @return int|null
     */
    public function getSeasonHash()
    {
        return $this->container['season_hash'];
    }

    /**
     * Sets season_hash
     *
     * @param int|null $season_hash If this item is related directly to a Season of Destiny, this is the hash identifier for that season.
     *
     * @return self
     */
    public function setSeasonHash($season_hash)
    {
        $this->container['season_hash'] = $season_hash;

        return $this;
    }

    /**
     * Gets is_wrapper
     *
     * @return bool|null
     */
    public function getIsWrapper()
    {
        return $this->container['is_wrapper'];
    }

    /**
     * Sets is_wrapper
     *
     * @param bool|null $is_wrapper If true, this is a dummy vendor-wrapped item template. Items purchased from Eververse will be \"wrapped\" by one of these items so that we can safely provide refund capabilities before the item is \"unwrapped\".
     *
     * @return self
     */
    public function setIsWrapper($is_wrapper)
    {
        $this->container['is_wrapper'] = $is_wrapper;

        return $this;
    }

    /**
     * Gets trait_ids
     *
     * @return string[]|null
     */
    public function getTraitIds()
    {
        return $this->container['trait_ids'];
    }

    /**
     * Sets trait_ids
     *
     * @param string[]|null $trait_ids Traits are metadata tags applied to this item. For example: armor slot, weapon type, foundry, faction, etc. These IDs come from the game and don't map to any content, but should still be useful.
     *
     * @return self
     */
    public function setTraitIds($trait_ids)
    {
        $this->container['trait_ids'] = $trait_ids;

        return $this;
    }

    /**
     * Gets hash
     *
     * @return int|null
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param int|null $hash The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
     *
     * @return self
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets index
     *
     * @return int|null
     */
    public function getIndex()
    {
        return $this->container['index'];
    }

    /**
     * Sets index
     *
     * @param int|null $index The index of the entity as it was found in the investment tables.
     *
     * @return self
     */
    public function setIndex($index)
    {
        $this->container['index'] = $index;

        return $this;
    }

    /**
     * Gets redacted
     *
     * @return bool|null
     */
    public function getRedacted()
    {
        return $this->container['redacted'];
    }

    /**
     * Sets redacted
     *
     * @param bool|null $redacted If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
     *
     * @return self
     */
    public function setRedacted($redacted)
    {
        $this->container['redacted'] = $redacted;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


