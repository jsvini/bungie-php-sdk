<?php
/**
 * DestinyDefinitionsItemsDestinyItemPlugDefinition
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Bungie.Net API
 *
 * These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.
 *
 * The version of the OpenAPI document: 2.9.2
 * Contact: support@bungie.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * DestinyDefinitionsItemsDestinyItemPlugDefinition Class Doc Comment
 *
 * @category Class
 * @description If an item is a Plug, its DestinyInventoryItemDefinition.plug property will be populated with an instance of one of these bad boys.  This gives information about when it can be inserted, what the plug&#39;s category is (and thus whether it is compatible with a socket... see DestinySocketTypeDefinition for information about Plug Categories and socket compatibility), whether it is enabled and other Plug info.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class DestinyDefinitionsItemsDestinyItemPlugDefinition implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Destiny.Definitions.Items.DestinyItemPlugDefinition';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'insertion_rules' => '\OpenAPI\Client\Model\DestinyDefinitionsItemsDestinyPlugRuleDefinition[]',
        'plug_category_identifier' => 'string',
        'plug_category_hash' => 'int',
        'on_action_recreate_self' => 'bool',
        'insertion_material_requirement_hash' => 'int',
        'preview_item_override_hash' => 'int',
        'enabled_material_requirement_hash' => 'int',
        'enabled_rules' => '\OpenAPI\Client\Model\DestinyDefinitionsItemsDestinyPlugRuleDefinition[]',
        'ui_plug_label' => 'string',
        'plug_style' => 'int',
        'plug_availability' => 'int',
        'alternate_ui_plug_label' => 'string',
        'alternate_plug_style' => 'int',
        'is_dummy_plug' => 'bool',
        'parent_item_override' => 'DestinyDefinitionsItemsDestinyParentItemOverride',
        'energy_capacity' => 'DestinyDefinitionsItemsDestinyEnergyCapacityEntry',
        'energy_cost' => 'DestinyDefinitionsItemsDestinyEnergyCostEntry'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'insertion_rules' => null,
        'plug_category_identifier' => null,
        'plug_category_hash' => 'uint32',
        'on_action_recreate_self' => null,
        'insertion_material_requirement_hash' => 'uint32',
        'preview_item_override_hash' => 'uint32',
        'enabled_material_requirement_hash' => 'uint32',
        'enabled_rules' => null,
        'ui_plug_label' => null,
        'plug_style' => 'int32',
        'plug_availability' => 'int32',
        'alternate_ui_plug_label' => null,
        'alternate_plug_style' => 'int32',
        'is_dummy_plug' => null,
        'parent_item_override' => null,
        'energy_capacity' => null,
        'energy_cost' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'insertion_rules' => 'insertionRules',
        'plug_category_identifier' => 'plugCategoryIdentifier',
        'plug_category_hash' => 'plugCategoryHash',
        'on_action_recreate_self' => 'onActionRecreateSelf',
        'insertion_material_requirement_hash' => 'insertionMaterialRequirementHash',
        'preview_item_override_hash' => 'previewItemOverrideHash',
        'enabled_material_requirement_hash' => 'enabledMaterialRequirementHash',
        'enabled_rules' => 'enabledRules',
        'ui_plug_label' => 'uiPlugLabel',
        'plug_style' => 'plugStyle',
        'plug_availability' => 'plugAvailability',
        'alternate_ui_plug_label' => 'alternateUiPlugLabel',
        'alternate_plug_style' => 'alternatePlugStyle',
        'is_dummy_plug' => 'isDummyPlug',
        'parent_item_override' => 'parentItemOverride',
        'energy_capacity' => 'energyCapacity',
        'energy_cost' => 'energyCost'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'insertion_rules' => 'setInsertionRules',
        'plug_category_identifier' => 'setPlugCategoryIdentifier',
        'plug_category_hash' => 'setPlugCategoryHash',
        'on_action_recreate_self' => 'setOnActionRecreateSelf',
        'insertion_material_requirement_hash' => 'setInsertionMaterialRequirementHash',
        'preview_item_override_hash' => 'setPreviewItemOverrideHash',
        'enabled_material_requirement_hash' => 'setEnabledMaterialRequirementHash',
        'enabled_rules' => 'setEnabledRules',
        'ui_plug_label' => 'setUiPlugLabel',
        'plug_style' => 'setPlugStyle',
        'plug_availability' => 'setPlugAvailability',
        'alternate_ui_plug_label' => 'setAlternateUiPlugLabel',
        'alternate_plug_style' => 'setAlternatePlugStyle',
        'is_dummy_plug' => 'setIsDummyPlug',
        'parent_item_override' => 'setParentItemOverride',
        'energy_capacity' => 'setEnergyCapacity',
        'energy_cost' => 'setEnergyCost'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'insertion_rules' => 'getInsertionRules',
        'plug_category_identifier' => 'getPlugCategoryIdentifier',
        'plug_category_hash' => 'getPlugCategoryHash',
        'on_action_recreate_self' => 'getOnActionRecreateSelf',
        'insertion_material_requirement_hash' => 'getInsertionMaterialRequirementHash',
        'preview_item_override_hash' => 'getPreviewItemOverrideHash',
        'enabled_material_requirement_hash' => 'getEnabledMaterialRequirementHash',
        'enabled_rules' => 'getEnabledRules',
        'ui_plug_label' => 'getUiPlugLabel',
        'plug_style' => 'getPlugStyle',
        'plug_availability' => 'getPlugAvailability',
        'alternate_ui_plug_label' => 'getAlternateUiPlugLabel',
        'alternate_plug_style' => 'getAlternatePlugStyle',
        'is_dummy_plug' => 'getIsDummyPlug',
        'parent_item_override' => 'getParentItemOverride',
        'energy_capacity' => 'getEnergyCapacity',
        'energy_cost' => 'getEnergyCost'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['insertion_rules'] = $data['insertion_rules'] ?? null;
        $this->container['plug_category_identifier'] = $data['plug_category_identifier'] ?? null;
        $this->container['plug_category_hash'] = $data['plug_category_hash'] ?? null;
        $this->container['on_action_recreate_self'] = $data['on_action_recreate_self'] ?? null;
        $this->container['insertion_material_requirement_hash'] = $data['insertion_material_requirement_hash'] ?? null;
        $this->container['preview_item_override_hash'] = $data['preview_item_override_hash'] ?? null;
        $this->container['enabled_material_requirement_hash'] = $data['enabled_material_requirement_hash'] ?? null;
        $this->container['enabled_rules'] = $data['enabled_rules'] ?? null;
        $this->container['ui_plug_label'] = $data['ui_plug_label'] ?? null;
        $this->container['plug_style'] = $data['plug_style'] ?? null;
        $this->container['plug_availability'] = $data['plug_availability'] ?? null;
        $this->container['alternate_ui_plug_label'] = $data['alternate_ui_plug_label'] ?? null;
        $this->container['alternate_plug_style'] = $data['alternate_plug_style'] ?? null;
        $this->container['is_dummy_plug'] = $data['is_dummy_plug'] ?? null;
        $this->container['parent_item_override'] = $data['parent_item_override'] ?? null;
        $this->container['energy_capacity'] = $data['energy_capacity'] ?? null;
        $this->container['energy_cost'] = $data['energy_cost'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets insertion_rules
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsItemsDestinyPlugRuleDefinition[]|null
     */
    public function getInsertionRules()
    {
        return $this->container['insertion_rules'];
    }

    /**
     * Sets insertion_rules
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsItemsDestinyPlugRuleDefinition[]|null $insertion_rules The rules around when this plug can be inserted into a socket, aside from the socket's individual restrictions.  The live data DestinyItemPlugComponent.insertFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
     *
     * @return self
     */
    public function setInsertionRules($insertion_rules)
    {
        $this->container['insertion_rules'] = $insertion_rules;

        return $this;
    }

    /**
     * Gets plug_category_identifier
     *
     * @return string|null
     */
    public function getPlugCategoryIdentifier()
    {
        return $this->container['plug_category_identifier'];
    }

    /**
     * Sets plug_category_identifier
     *
     * @param string|null $plug_category_identifier The string identifier for the plug's category. Use the socket's DestinySocketTypeDefinition.plugWhitelist to determine whether this plug can be inserted into the socket.
     *
     * @return self
     */
    public function setPlugCategoryIdentifier($plug_category_identifier)
    {
        $this->container['plug_category_identifier'] = $plug_category_identifier;

        return $this;
    }

    /**
     * Gets plug_category_hash
     *
     * @return int|null
     */
    public function getPlugCategoryHash()
    {
        return $this->container['plug_category_hash'];
    }

    /**
     * Sets plug_category_hash
     *
     * @param int|null $plug_category_hash The hash for the plugCategoryIdentifier. You can use this instead if you wish: I put both in the definition for debugging purposes.
     *
     * @return self
     */
    public function setPlugCategoryHash($plug_category_hash)
    {
        $this->container['plug_category_hash'] = $plug_category_hash;

        return $this;
    }

    /**
     * Gets on_action_recreate_self
     *
     * @return bool|null
     */
    public function getOnActionRecreateSelf()
    {
        return $this->container['on_action_recreate_self'];
    }

    /**
     * Sets on_action_recreate_self
     *
     * @param bool|null $on_action_recreate_self If you successfully socket the item, this will determine whether or not you get \"refunded\" on the plug.
     *
     * @return self
     */
    public function setOnActionRecreateSelf($on_action_recreate_self)
    {
        $this->container['on_action_recreate_self'] = $on_action_recreate_self;

        return $this;
    }

    /**
     * Gets insertion_material_requirement_hash
     *
     * @return int|null
     */
    public function getInsertionMaterialRequirementHash()
    {
        return $this->container['insertion_material_requirement_hash'];
    }

    /**
     * Sets insertion_material_requirement_hash
     *
     * @param int|null $insertion_material_requirement_hash If inserting this plug requires materials, this is the hash identifier for looking up the DestinyMaterialRequirementSetDefinition for those requirements.
     *
     * @return self
     */
    public function setInsertionMaterialRequirementHash($insertion_material_requirement_hash)
    {
        $this->container['insertion_material_requirement_hash'] = $insertion_material_requirement_hash;

        return $this;
    }

    /**
     * Gets preview_item_override_hash
     *
     * @return int|null
     */
    public function getPreviewItemOverrideHash()
    {
        return $this->container['preview_item_override_hash'];
    }

    /**
     * Sets preview_item_override_hash
     *
     * @param int|null $preview_item_override_hash In the game, if you're inspecting a plug item directly, this will be the item shown with the plug attached. Look up the DestinyInventoryItemDefinition for this hash for the item.
     *
     * @return self
     */
    public function setPreviewItemOverrideHash($preview_item_override_hash)
    {
        $this->container['preview_item_override_hash'] = $preview_item_override_hash;

        return $this;
    }

    /**
     * Gets enabled_material_requirement_hash
     *
     * @return int|null
     */
    public function getEnabledMaterialRequirementHash()
    {
        return $this->container['enabled_material_requirement_hash'];
    }

    /**
     * Sets enabled_material_requirement_hash
     *
     * @param int|null $enabled_material_requirement_hash It's not enough for the plug to be inserted. It has to be enabled as well. For it to be enabled, it may require materials. This is the hash identifier for the DestinyMaterialRequirementSetDefinition for those requirements, if there is one.
     *
     * @return self
     */
    public function setEnabledMaterialRequirementHash($enabled_material_requirement_hash)
    {
        $this->container['enabled_material_requirement_hash'] = $enabled_material_requirement_hash;

        return $this;
    }

    /**
     * Gets enabled_rules
     *
     * @return \OpenAPI\Client\Model\DestinyDefinitionsItemsDestinyPlugRuleDefinition[]|null
     */
    public function getEnabledRules()
    {
        return $this->container['enabled_rules'];
    }

    /**
     * Sets enabled_rules
     *
     * @param \OpenAPI\Client\Model\DestinyDefinitionsItemsDestinyPlugRuleDefinition[]|null $enabled_rules The rules around whether the plug, once inserted, is enabled and providing its benefits.  The live data DestinyItemPlugComponent.enableFailIndexes will be an index into this array, so you can pull out the failure strings appropriate for the user.
     *
     * @return self
     */
    public function setEnabledRules($enabled_rules)
    {
        $this->container['enabled_rules'] = $enabled_rules;

        return $this;
    }

    /**
     * Gets ui_plug_label
     *
     * @return string|null
     */
    public function getUiPlugLabel()
    {
        return $this->container['ui_plug_label'];
    }

    /**
     * Sets ui_plug_label
     *
     * @param string|null $ui_plug_label Plugs can have arbitrary, UI-defined identifiers that the UI designers use to determine the style applied to plugs. Unfortunately, we have neither a definitive list of these labels nor advance warning of when new labels might be applied or how that relates to how they get rendered. If you want to, you can refer to known labels to change your own styles: but know that new ones can be created arbitrarily, and we have no way of associating the labels with any specific UI style guidance... you'll have to piece that together on your end. Or do what we do, and just show plugs more generically, without specialized styles.
     *
     * @return self
     */
    public function setUiPlugLabel($ui_plug_label)
    {
        $this->container['ui_plug_label'] = $ui_plug_label;

        return $this;
    }

    /**
     * Gets plug_style
     *
     * @return int|null
     */
    public function getPlugStyle()
    {
        return $this->container['plug_style'];
    }

    /**
     * Sets plug_style
     *
     * @param int|null $plug_style plug_style
     *
     * @return self
     */
    public function setPlugStyle($plug_style)
    {
        $this->container['plug_style'] = $plug_style;

        return $this;
    }

    /**
     * Gets plug_availability
     *
     * @return int|null
     */
    public function getPlugAvailability()
    {
        return $this->container['plug_availability'];
    }

    /**
     * Sets plug_availability
     *
     * @param int|null $plug_availability Indicates the rules about when this plug can be used. See the PlugAvailabilityMode enumeration for more information!
     *
     * @return self
     */
    public function setPlugAvailability($plug_availability)
    {
        $this->container['plug_availability'] = $plug_availability;

        return $this;
    }

    /**
     * Gets alternate_ui_plug_label
     *
     * @return string|null
     */
    public function getAlternateUiPlugLabel()
    {
        return $this->container['alternate_ui_plug_label'];
    }

    /**
     * Sets alternate_ui_plug_label
     *
     * @param string|null $alternate_ui_plug_label If the plug meets certain state requirements, it may have an alternative label applied to it. This is the alternative label that will be applied in such a situation.
     *
     * @return self
     */
    public function setAlternateUiPlugLabel($alternate_ui_plug_label)
    {
        $this->container['alternate_ui_plug_label'] = $alternate_ui_plug_label;

        return $this;
    }

    /**
     * Gets alternate_plug_style
     *
     * @return int|null
     */
    public function getAlternatePlugStyle()
    {
        return $this->container['alternate_plug_style'];
    }

    /**
     * Sets alternate_plug_style
     *
     * @param int|null $alternate_plug_style The alternate plug of the plug: only applies when the item is in states that only the server can know about and control, unfortunately. See AlternateUiPlugLabel for the related label info.
     *
     * @return self
     */
    public function setAlternatePlugStyle($alternate_plug_style)
    {
        $this->container['alternate_plug_style'] = $alternate_plug_style;

        return $this;
    }

    /**
     * Gets is_dummy_plug
     *
     * @return bool|null
     */
    public function getIsDummyPlug()
    {
        return $this->container['is_dummy_plug'];
    }

    /**
     * Sets is_dummy_plug
     *
     * @param bool|null $is_dummy_plug If TRUE, this plug is used for UI display purposes only, and doesn't have any interesting effects of its own.
     *
     * @return self
     */
    public function setIsDummyPlug($is_dummy_plug)
    {
        $this->container['is_dummy_plug'] = $is_dummy_plug;

        return $this;
    }

    /**
     * Gets parent_item_override
     *
     * @return DestinyDefinitionsItemsDestinyParentItemOverride|null
     */
    public function getParentItemOverride()
    {
        return $this->container['parent_item_override'];
    }

    /**
     * Sets parent_item_override
     *
     * @param DestinyDefinitionsItemsDestinyParentItemOverride|null $parent_item_override Do you ever get the feeling that a system has become so overburdened by edge cases that it probably should have become some other system entirely? So do I!  In totally unrelated news, Plugs can now override properties of their parent items. This is some of the relevant definition data for those overrides.  If this is populated, it will have the override data to be applied when this plug is applied to an item.
     *
     * @return self
     */
    public function setParentItemOverride($parent_item_override)
    {
        $this->container['parent_item_override'] = $parent_item_override;

        return $this;
    }

    /**
     * Gets energy_capacity
     *
     * @return DestinyDefinitionsItemsDestinyEnergyCapacityEntry|null
     */
    public function getEnergyCapacity()
    {
        return $this->container['energy_capacity'];
    }

    /**
     * Sets energy_capacity
     *
     * @param DestinyDefinitionsItemsDestinyEnergyCapacityEntry|null $energy_capacity IF not null, this plug provides Energy capacity to the item in which it is socketed. In Armor 2.0 for example, is implemented in a similar way to Masterworks, where visually it's a single area of the UI being clicked on to \"Upgrade\" to higher energy levels, but it's actually socketing new plugs.
     *
     * @return self
     */
    public function setEnergyCapacity($energy_capacity)
    {
        $this->container['energy_capacity'] = $energy_capacity;

        return $this;
    }

    /**
     * Gets energy_cost
     *
     * @return DestinyDefinitionsItemsDestinyEnergyCostEntry|null
     */
    public function getEnergyCost()
    {
        return $this->container['energy_cost'];
    }

    /**
     * Sets energy_cost
     *
     * @param DestinyDefinitionsItemsDestinyEnergyCostEntry|null $energy_cost IF not null, this plug has an energy cost. This contains the details of that cost.
     *
     * @return self
     */
    public function setEnergyCost($energy_cost)
    {
        $this->container['energy_cost'] = $energy_cost;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


